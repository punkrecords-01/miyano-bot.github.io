<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIYANO // PRODUCT_DESIGN</title>
    <meta name="description" content="UX Strategy and Design focused on impact: case studies across telecom, logistics, bowling operations, and fashion catalog platforms." />
        <link rel="canonical" href="https://miyano-bot.github.io/" />
        <meta name="robots" content="index, follow" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="MIYANO // Product Design Portfolio" />
        <meta property="og:description" content="UX strategy and product design case studies focused on measurable impact across complex systems." />
        <meta property="og:url" content="https://miyano-bot.github.io/" />
        <meta property="og:image" content="https://miyano-bot.github.io/assets/algar/thumb.svg" />
        <meta property="og:site_name" content="MIYANO" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="MIYANO // Product Design Portfolio" />
        <meta name="twitter:description" content="Case studies in UX strategy, systemic design, and AI-assisted product execution." />
        <meta name="twitter:image" content="https://miyano-bot.github.io/assets/algar/thumb.svg" />
        <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "Person",
            "name": "Miyano",
            "jobTitle": "Senior UX Designer",
            "url": "https://miyano-bot.github.io/",
            "email": "mailto:hello@miyano.net",
            "sameAs": [
                "https://www.linkedin.com/in/miyano/"
            ],
            "knowsAbout": [
                "UX Strategy",
                "Product Design",
                "Design Systems",
                "AI-assisted Prototyping"
            ],
            "workExample": [
                "https://miyano-bot.github.io/cases/algar.html",
                "https://miyano-bot.github.io/cases/volpi.html",
                "https://miyano-bot.github.io/cases/torre-controle.html",
                "https://miyano-bot.github.io/cases/sistema-pistas-boliche.html",
                "https://miyano-bot.github.io/cases/fashion-store-catalog.html"
            ]
        }
        </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
        "three/": "https://unpkg.com/three@0.128.0/"
      }
    }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050505;
            --surface: #0f0f0f;
            --accent: #00ff88; /* Bright Green */
            --accent-glow: rgba(0, 255, 136, 0.3);
            --text-main: #ffffff;
            --text-dim: #888;
            --border: #222;
            --font-main: 'Inter', sans-serif;
        }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: var(--font-main);
            overflow-x: hidden;
            line-height: 1.5;
            position: relative;
        }

        /* Ambient Lighting Effects */


        .bg-noise {
            position: fixed;
            inset: 0;
            z-index: 5;
            opacity: 0.05;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3BaseFilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
        }

        /* Ensure content sits above background layers */
        main {
            position: relative;
            z-index: 10;
        }

        @keyframes kineticDrift {
            0% { background-position: 0 0; }
            100% { background-position: 60px 60px; }
        }

        .mono { font-family: 'JetBrains Mono', monospace; }

        /* Fragmented Bit Nav - Minimal but tactile */
        .hud-nav {
            position: fixed;
            right: 28px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            width: 40px;
            height: 120px;
            pointer-events: none;
        }

        .hud-link {
            position: absolute;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            pointer-events: auto;
            transition: all 0.4s ease;
            opacity: 0.35;
        }

        /* Scattered "chaotic" feel in a tight cluster */
        .hud-link:nth-child(1) { top: 0; left: 10px; }
        .hud-link:nth-child(2) { top: 35px; left: -4px; }
        .hud-link:nth-child(3) { top: 65px; left: 14px; }
        .hud-link:nth-child(4) { top: 95px; left: 0px; }

        .nav-bit {
            width: 4px;
            height: 4px;
            background: #fff;
            transition: all 0.3s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .hud-link:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .hud-link:hover .nav-bit {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
            transform: scale(1.8);
        }

        .hud-link.active {
            opacity: 1;
        }

        .hud-link.active .nav-bit {
            background: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
            width: 12px;
            height: 2px; /* active is a sharper, more visible dash */
        }

        /* Nav Arrows Fallback */
        .nav-arrows {
            position: fixed;
            bottom: 32px;
            right: 32px;
            z-index: 1000;
            display: flex;
            gap: 12px;
        }

        .arrow-btn {
            width: 44px;
            height: 44px;
            background: rgba(10, 10, 10, 0.4);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            transition: all 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            cursor: pointer;
        }

        .arrow-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--accent);
            color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .arrow-btn svg {
            width: 18px;
            height: 18px;
            transition: transform 0.3s ease;
        }

        .arrow-btn:active {
            transform: scale(0.95);
        }

        .arrow-btn.is-end svg {
            transform: rotate(180deg);
        }

        /* Tooltip-less design - purely visual cues */
        @media (max-width: 768px) {
            .hud-nav { right: 12px; }
        }

        /* Site Logo - Restored */
        .site-logo {
            position: fixed;
            top: 20px;
            left: 40px;
            z-index: 1002;
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 2px 4px;
            background: transparent;
            border: none;
            transition: none;
            cursor: pointer;
            text-decoration: none;
        }

        .logo-canvas {
            width: 36px;
            height: 36px;
            display: block;
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            opacity: 0.8;
            will-change: transform;
        }

        .logo-text {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.12em;
            color: var(--text-main);
            text-transform: uppercase;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .site-logo:hover .logo-text {
            color: var(--accent);
            text-shadow: 0 0 12px var(--accent-glow);
            transform: translateX(2px);
        }

        .site-logo:hover .logo-canvas {
            transform: scale(1.08); /* Reduced from 1.1 for less "jumpiness" */
            opacity: 1;
            /* Removed filter: drop-shadow as it jitters on canvas during animation */
        }

        @media (max-width: 640px) {
            .site-logo { left: 16px; padding: 4px; }
        }

        /* Grid Layout */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 24px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 40px;
        }

        /* Hero */
        .hero-section {
            height: 100vh;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 10;
            overflow: hidden;
        }

        .bg-hero-container {
            position: absolute;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            background: #000;
        }

        #bg-wave-canvas, #bg-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #bg-wave-canvas {
            opacity: 0.6;
            z-index: 0;
        }

        #bg-canvas {
            z-index: 1;
            pointer-events: auto; /* Allow dragging cubes */
        }

        .bg-vignette {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, transparent 0%, var(--bg) 95%);
            z-index: 2;
            pointer-events: none;
        }
        .hero-title {
            font-family: 'JetBrains Mono';
            font-size: 6vw;
            line-height: 0.9;
            letter-spacing: -0.05em;
            text-transform: uppercase;
            font-weight: 800;
            /* smooth transform for hero transitions */
            transition: opacity 320ms ease, transform 420ms cubic-bezier(0.2, 0.9, 0.28, 1);
            will-change: opacity, transform;
        }
        .badge {
            display: inline-block;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--text-dim);
            letter-spacing: 0.12em;
            margin-bottom: 18px;
            font-family: 'JetBrains Mono';
            background: linear-gradient(90deg, rgba(0,255,136,0.06), rgba(0,255,136,0.02));
            border-left: 3px solid var(--accent);
            border-radius: 6px;
            padding-left: 10px;
            text-transform: uppercase;
            font-weight: 600;
            transition: opacity 220ms ease, transform 320ms cubic-bezier(0.2, 0.9, 0.28, 1);
        }

        .badge:hover {
            color: var(--text-main);
            background: linear-gradient(90deg, rgba(0,255,136,0.09), rgba(0,255,136,0.04));
        }

        /* Animation helper classes for hero A/B demo */
        .hero-fade-out {
            opacity: 0; transform: translateY(-8px) scale(0.995);
        }
        .hero-fade-in {
            opacity: 1; transform: translateY(0px) scale(1);
        }

        /* 3D flip title animation (Traf-inspired) */
        .title-clip { display:inline-block; overflow:hidden; vertical-align:middle; perspective: 800px; -webkit-perspective: 800px; }
        .title-word { display:inline-flex; white-space: nowrap; margin-right: 0.35ch; align-items: center; }

        /* Geometric Stealth HUD Cursor */
        body.has-custom-cursor { cursor: none !important; }
        #custom-cursor { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            z-index: 999999; 
            opacity: 0; 
            transition: opacity 400ms ease;
            mix-blend-mode: difference;
            color: #fff;
        }

        .cursor-svg {
            position: absolute;
            top: 0; left: 0;
            will-change: transform;
            overflow: visible;
        }

        .cursor-outer {
            transition: d 0.4s cubic-bezier(0.19, 1, 0.22, 1), stroke 0.3s, opacity 0.3s;
        }

        .cursor-inner {
            transition: d 0.4s cubic-bezier(0.19, 1, 0.22, 1), stroke 0.3s, stroke-width 0.3s, fill 0.3s;
        }

        .hover-details path, .hover-details rect {
            transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .scan-line-top, .scan-line-bottom {
            transform-origin: center;
        }

        .reticle-h, .reticle-v {
            transition: opacity 0.3s ease, stroke-width 0.3s ease;
        }

        .cursor-status {
            position: absolute;
            top: 0; left: 0;
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 7px;
            letter-spacing: 0.1em;
            opacity: 0.5;
            pointer-events: none;
            will-change: transform;
        }

        .status-mode { color: #fff; }
        .status-coords { color: rgba(255,255,255,0.6); }

        /* Hover States (Geometric Morph) */
        body.cursor-hovering .cursor-inner { 
            d: path("M30 26 A4 4 0 1 0 30 34 A4 4 0 1 0 30 26"); /* Slightly larger solid center dot */
            fill: var(--accent);
            stroke: var(--accent); 
            stroke-width: 0; 
        }
        body.cursor-hovering .cursor-outer { 
            d: path("M30 16 A14 14 0 1 0 30 44 A14 14 0 1 0 30 16"); /* Tighter outer ring */
            stroke: var(--accent); 
            stroke-width: 1; 
            opacity: 0.9;
            fill: none;
        }
        body.cursor-hovering .wave-1, 
        body.cursor-hovering .wave-2, 
        body.cursor-hovering .wave-3 { 
            transform-origin: 30px 30px;
        }

        body.cursor-hovering .wave-1 { opacity: 1; animation: ripple 1.8s infinite cubic-bezier(0.2, 0, 0.2, 1); }
        body.cursor-hovering .wave-2 { opacity: 1; animation: ripple 1.8s infinite cubic-bezier(0.2, 0, 0.2, 1) 0.6s; }
        body.cursor-hovering .wave-3 { opacity: 1; animation: ripple 1.8s infinite cubic-bezier(0.2, 0, 0.2, 1) 1.2s; }
        
        body.cursor-hovering .reticle-h { opacity: 0; }
        body.cursor-hovering .reticle-v { opacity: 0; }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
        }

        @keyframes scanMove {
            0%, 100% { transform: scaleX(0.8); opacity: 0.2; }
            50% { transform: scaleX(1.2); opacity: 0.8; }
        }

        @keyframes verticalPulse {
            0%, 100% { transform: scaleY(1); opacity: 0.8; }
            50% { transform: scaleY(1.2); opacity: 0.4; }
        }

        body.cursor-hovering .cursor-status { opacity: 1; }
        body.cursor-hovering .status-mode { color: var(--accent); }

        /* Block Mode fallback */
        body.cursor-mode-block .cursor-v-bracket,
        body.cursor-mode-block .cursor-v-info,
        body.cursor-mode-block .cursor-v-trail { display: none; }
        body.cursor-mode-block .cursor-v-center { 
            width: 12px; height: 18px; border-radius: 0; background: #fff; mix-blend-mode: normal; 
        }

        @media (prefers-reduced-motion: reduce){
            #custom-cursor, body.has-custom-cursor { display: none !important; }
        }
        .title-space { display:inline-block; width: 0.35ch; }
        .title-letter { display:inline-block; transition: transform 520ms cubic-bezier(0.2,0.9,0.28,1), opacity 360ms ease, text-shadow 420ms ease; transform-origin: 50% 60%; transform-style: preserve-3d; backface-visibility: hidden; will-change: transform, opacity; vertical-align: middle; overflow: hidden; }
        .title-letter.letter-enter { transform: rotateX(80deg) translateY(18px) translateZ(6px) scale(0.985); opacity: 0; }
        .title-letter.letter-exit { transform: rotateX(-30deg) translateY(-20px) translateZ(-2px) scale(0.98); opacity: 0; }
        .title-letter.glow { text-shadow: 0 0 10px rgba(255,0,255,0.25), 0 0 10px rgba(0,255,255,0.25); }
        /* Refined Terminal Decode Effect */
        .title-letter.decoding { color: transparent; opacity: 0; transition: none; font-family: 'JetBrains Mono', monospace; position: relative; }
        .title-letter.decoding.active { color: #fff; opacity: 1; text-shadow: -1.5px 0 0 #ff00ff, 1.5px 0 0 #00ffff, 0 0 6px rgba(255,255,255,0.8); }
        /* The glitchy terminal block cursor */
        .title-letter.has-cursor::after { 
            content: ''; 
            position: absolute; 
            inset: 0; 
            background: #fff; 
            box-shadow: -2px 0 0 #ff00ff, 2px 0 0 #00ffff; 
            z-index: 1; 
            animation: blinkGlitch 80ms infinite;
        }
        .title-letter.settled { transform: none; text-shadow: none; opacity: 1; color: inherit; transition: color 200ms ease; }
        @keyframes blinkGlitch { 
            0%, 100% { opacity: 1; transform: translateX(0); } 
            50% { opacity: 0.8; transform: translateX(1px); } 
        }
        
        @media (max-width: 640px) {
            .title-word { margin-right: 0.25ch; }
            .title-space { width: 0.25ch; }
        }
        @media (prefers-reduced-motion: reduce) {
            .title-letter { transition: none !important; }
            .title-letter.letter-enter, .title-letter.letter-exit { transform: none !important; opacity: 1 !important; }
        }

        /* Dev title controls removed (production) */

        /* Glitch effect layers */
        .title-glitch { position: relative; display:inline-block; }
        .title-glitch .glitch-layer { position:absolute; top:0; left:0; right:0; bottom:0; pointer-events:none; mix-blend-mode: screen; opacity:0; }
        .glitch-layer.layer-r { color: rgba(255,0,0,0.85); transform: translateX(-6px) translateY(0); }
        .glitch-layer.layer-g { color: rgba(0,255,136,0.85); transform: translateX(6px) translateY(0); }
        .glitch-animate .glitch-layer { animation: glitch-anim 420ms cubic-bezier(0.2,0.9,0.28,1) forwards; }
        @keyframes glitch-anim { 0% { opacity:1; transform: translateX(6px) skewX(-6deg) scale(1.02); } 60% { opacity:0.7; transform: translateX(-4px) skewX(3deg) scale(1.0); } 100% { opacity:0; transform: translateX(0) scale(1); } }

        /* CRT style */
        .title-crt { color:#b3ffb3; font-family: 'Courier Prime', monospace; letter-spacing:0.02em; text-shadow: 0 0 2px rgba(0,255,136,0.15); }
        .crt-scanline { position:absolute; inset:0; background-image: linear-gradient(transparent 50%, rgba(0,0,0,0.06) 51%); background-size:100% 4px; pointer-events:none; mix-blend-mode: overlay; opacity:0.22; }

        /* Particle canvas overlay */
        .particle-layer { position:absolute; left:0; top:0; pointer-events:none; z-index:9999; }
        .title-indicator { margin-top:8px; }
        .title-hint { font-size:12px; color:var(--text-dim); margin-left:8px; }
        

        /* Reuseable Minimal Section Header */
        .section-header-main {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 12px;
            margin-bottom: 64px; /* Slightly tighter */
        }

        .section-header-main .header-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.25em;
            text-transform: uppercase;
        }

        .section-header-main h2 {
            font-size: 2rem;
            font-weight: 500;
            line-height: 1.2;
            letter-spacing: -0.01em;
            max-width: 550px;
            color: #fff;
            /* Prevent ambient blend/lighting from shading the title */
            mix-blend-mode: normal;
            text-shadow: none;
        }

        .section-header-main .highlight {
            color: inherit;
            font-style: italic;
        }

        .section-header-main .spec-list {
            display: flex;
            gap: 16px;
            margin-top: 4px;
        }

        .section-header-main .spec-item {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.25);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .section-header-main .spec-item:not(:last-child)::after {
            content: '/';
            margin-left: 16px;
            opacity: 0.2;
        }

        /* Works Grid - Bento Box Layout */
        .work-bento {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 20px;
            margin-bottom: 80px;
        }

        .work-card {
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.4) 0%, rgba(10, 10, 10, 0.3) 100%);
            backdrop-filter: blur(40px) saturate(140%);
            border: 2px solid;
            border-color: rgba(255, 255, 255, 0.15);
            transition: all 0.5s cubic-bezier(0.2, 0.9, 0.3, 1);
            min-height: 420px;
            display: flex;
            flex-direction: column;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 2px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
        }

        .work-card.featured {
            grid-column: span 12;
            min-height: 520px;
        }

        .work-card.medium {
            grid-column: span 6;
            min-height: 460px;
        }

        /* Asymmetrical logic for side-by-side cards */
        @media (min-width: 768px) {
            .work-card.medium:nth-of-type(even) {
                grid-column: span 7;
                min-height: 500px;
            }
            .work-card.medium:nth-of-type(odd):not(.featured) {
                grid-column: span 5;
                min-height: 560px; /* Staggered height */
            }
        }

        /* Ensure all cards have identical glass properties */
        .work-card.featured,
        .work-card.medium {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.4) 0%, rgba(10, 10, 10, 0.3) 100%);
            backdrop-filter: blur(40px) saturate(140%);
            border: 2px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 2px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -2px 4px rgba(0, 0, 0, 0.6);
        }

        .card-link {
            display: flex;
            flex-direction: column;
            height: 100%;
            text-decoration: none;
            color: inherit;
            position: relative;
            z-index: 1;
            padding: 40px;
        }

        .card-bg {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            transition: transform 0.6s cubic-bezier(0.2, 0.9, 0.3, 1), filter 0.4s ease, opacity 0.4s ease;
            filter: brightness(0.5) saturate(0.7);
            opacity: 0.5;
            z-index: 0;
        }

        .work-card:hover .card-bg {
            transform: scale(1.05);
            filter: brightness(0.6) saturate(0.9);
            opacity: 0.6;
        }

        .card-index {
            font-family: 'JetBrains Mono', monospace;
            font-size: 120px;
            font-weight: 900;
            line-height: 1;
            color: rgba(0,255,136,0.08);
            position: absolute;
            top: 20px;
            right: 30px;
            z-index: 1;
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .work-card:hover .card-index {
            color: rgba(0,255,136,0.14);
            transform: translateY(-8px);
        }

        .card-content {
            position: relative;
            z-index: 2;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: -4px;
        }

        .card-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent);
            opacity: 0.5;
            display: flex;
            align-items: center;
        }
        
        .card-tag::before {
            content: "";
            width: 3px;
            height: 3px;
            background: var(--accent);
            margin-right: 6px;
            border-radius: 50%;
        }

        .card-meta {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent);
            font-weight: 600;
        }

        .card-title {
            font-size: 2.8rem;
            font-weight: 900;
            line-height: 0.95;
            letter-spacing: -0.03em;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .work-card.medium .card-title {
            font-size: 2.2rem;
        }

        .card-excerpt {
            font-size: 1rem;
            line-height: 1.6;
            color: #d4d4d4;
            max-width: 600px;
            margin-bottom: 24px;
        }

        .work-card.medium .card-excerpt {
            font-size: 0.92rem;
        }

        .card-metrics {
            display: flex;
            gap: 32px;
            margin-top: auto;
            padding-top: 24px;
        }

        .card-metrics.compact {
            gap: 24px;
        }

        .metric {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent);
            line-height: 1;
        }

        .work-card.medium .metric-value {
            font-size: 1.4rem;
        }

        .metric-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
        }

        .card-cta {
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--accent);
            font-weight: 600;
        }

        .card-3d-viz {
            display: block !important;
            opacity: 0.8;
        }

        .cta-arrow {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .work-card:hover .cta-arrow {
            transform: translateX(8px);
        }

        .work-card:hover {
            border-color: rgba(0, 255, 136, 0.5);
            transform: translateY(-10px) scale(1.01);
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.5) 0%, rgba(20, 20, 20, 0.4) 100%);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.9),
                0 8px 32px rgba(0, 255, 136, 0.2),
                0 0 80px rgba(0, 255, 136, 0.1),
                inset 0 2px 2px rgba(255, 255, 255, 0.5),
                inset 0 -3px 6px rgba(0, 0, 0, 0.7);
        }

        .card-3d-viz {
            position: absolute;
            inset: 0;
            z-index: 5;
            pointer-events: none;
            display: block !important;
            opacity: 1;
        }

        @media (max-width: 768px) {
            .work-card.featured,
            .work-card.medium {
                grid-column: span 12;
                min-height: 380px;
            }
            .card-link { padding: 28px; }
            .card-title { font-size: 2rem; }
            .card-index { font-size: 80px; top: 10px; right: 20px; }
        }

        /* Particles canvas overlay */
        #bg-particles {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* Reveal on scroll */
        .reveal { opacity: 0; transform: translateY(14px) scale(0.996); transition: opacity 0.6s ease, transform 0.6s cubic-bezier(.2,.9,.3,1); }
        .reveal.visible { opacity: 1; transform: translateY(0) scale(1); }

        /* Section headings */
        .section-heading { position: relative; }

        /* Stack Process Diagram - Ultra Refined */
        .stack-container {
            perspective: 2500px;
        }

        .stack-visual {
            transform-style: preserve-3d;
            height: 100%;
            min-height: 540px; /* More compact */
            display: flex;
            align-items: center; /* Centered relative to text block */
            justify-content: center;
            transition: transform 0.3s ease-out;
        }

        .stack-layers {
            position: relative;
            width: 320px; 
            height: 220px; 
            transform-style: preserve-3d;
            /* Moving to a steeper angle (closer to 90) to see it more from the "side" 
               rather than looking "down" at the faces */
            transform: rotateX(72deg) rotateZ(-38deg); 
            transition: transform 320ms cubic-bezier(0.2, 0.9, 0.3, 1);
        }

        /* Hovering the visual container tilts it even more to profile */
        .stack-visual:hover .stack-layers {
            transform: rotateX(65deg) rotateZ(-32deg);
        }

        .stack-layer {
            position: absolute;
            inset: 0;
            background-color: rgba(15, 15, 15, 0.99);
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: center;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transform-style: preserve-3d;
            transition: 
                transform 0.8s cubic-bezier(0.16, 1, 0.3, 1),
                background 0.6s ease,
                border-color 0.6s ease,
                box-shadow 0.6s ease;
            cursor: pointer;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.5),
                inset 0 0 0 1px rgba(255,255,255,0.05); /* Sharper internal top edge */
        }

        /* 3D Thickness (Sides) - Full Box Effect */
        .stack-layer::before {
            content: attr(data-label);
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            height: 24px;
            background: #121212;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-top: none;
            transform: rotateX(-90deg);
            transform-origin: top;
            display: flex;
            align-items: center;
            padding-left: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            box-sizing: border-box;
            transition: all 0.6s ease;
        }

        .stack-layer::after {
            content: var(--step-number, "↓");
            position: absolute;
            top: 0;
            left: 100%;
            width: 24px;
            height: 100%;
            background: #0d0d0d;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: none;
            transform: rotateY(90deg);
            transform-origin: left;
            transition: all 0.6s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 9px;
            font-family: 'JetBrains Mono', monospace;
        }

        .stack-layer.layer-7 { --step-number: "01"; }
        .stack-layer.layer-6 { --step-number: "02"; }
        .stack-layer.layer-5 { --step-number: "03"; }
        .stack-layer.layer-4 { --step-number: "04"; }
        .stack-layer.layer-3 { --step-number: "05"; }
        .stack-layer.layer-2 { --step-number: "06"; }
        .stack-layer.layer-1 { --step-number: "07"; }

        .stack-layer.is-active::before,
        .stack-layer:hover::before {
            background: #1a1a1a;
            color: var(--accent);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .stack-layer.is-active::after,
        .stack-layer:hover::after {
            color: var(--accent);
            border-color: rgba(0, 255, 136, 0.4);
            content: "↓" !important; /* Switch to arrow on active */
        }

        /* Technical Scanning Animation for Highlight Layer */
        @keyframes scan-highlight {
            0% { transform: translateY(-50px); opacity: 0; }
            10% { opacity: 0.5; }
            90% { opacity: 0.5; }
            100% { transform: translateY(150px); opacity: 0; }
        }

        .layer-highlight .layer-inner::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 1px;
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            animation: scan-highlight 3s linear infinite;
            pointer-events: none;
            z-index: 10;
        }

        /* Added Left and Back sides for "Full Box" feel even if hidden (completes volume) */
        .stack-layer-back {
            position: absolute;
            bottom: 100%;
            left: 0;
            width: 100%;
            height: 24px;
            background: #080808;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: rotateX(90deg);
            transform-origin: bottom;
            pointer-events: none;
        }

        .stack-layer-left {
            position: absolute;
            top: 0;
            right: 100%;
            width: 24px;
            height: 100%;
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: rotateY(-90deg);
            transform-origin: right;
            pointer-events: none;
        }

        /* The reveal movement: Active/Hovered layer lifts slightly, siblings above lift MORE */
        .stack-layer:hover,
        .stack-layer.is-active {
            transform: translateZ(calc(var(--z-base, 0px) + 30px)) scale(1.02);
            background-color: rgba(22, 22, 22, 0.99);
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.05) 1px, transparent 1px);
            border-color: var(--accent);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.15);
            animation: gridPulse 4s infinite alternate ease-in-out;
        }

        @keyframes gridPulse {
            0% { background-size: 20px 20px; }
            100% { background-size: 22px 22px; }
        }

        .stack-layer:hover ~ .stack-layer,
        .stack-layer.is-active ~ .stack-layer {
            transform: translateZ(calc(var(--z-base, 0px) + 100px));
        }

        /* Specific base heights (Reduced for steeper side-view) */
        .layer-1 { --z-base: -120px; transform: translateZ(var(--z-base)); }
        .layer-2 { --z-base: -80px; transform: translateZ(var(--z-base)); }
        .layer-3 { --z-base: -40px; transform: translateZ(var(--z-base)); }
        .layer-4 { --z-base: 0px; transform: translateZ(var(--z-base)); }
        .layer-5 { --z-base: 40px; transform: translateZ(var(--z-base)); }
        .layer-6 { --z-base: 80px; transform: translateZ(var(--z-base)); }
        .layer-7 { --z-base: 120px; transform: translateZ(var(--z-base)); }

        .stack-layer:hover::before,
        .stack-layer.is-active::before {
            border-color: var(--accent);
            color: #fff;
            background: rgba(0, 255, 136, 0.1);
        }

        .stack-layer:hover::after,
        .stack-layer.is-active::after {
            border-color: var(--accent);
            content: "↓";
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-size: 10px;
            font-weight: bold;
        }

        /* Highlight Managed Services style (RGB edge) */
        .layer-highlight {
            border-color: rgba(0, 255, 136, 0.3);
        }
        .layer-highlight:hover {
            border-color: var(--accent);
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.2);
        }

        /* Inner graphics animations */
        .layer-inner svg {
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .stack-layer:hover .layer-inner svg {
            transform: scale(1.1);
            stroke-opacity: 0.8;
            filter: drop-shadow(0 0 8px var(--accent));
        }

        .layer-wire {
            width: 70%;
            height: 70%;
            stroke: rgba(255, 255, 255, 0.15);
            fill: none;
            stroke-width: 0.8;
        }

        /* Floating Group Labels (Match steeper angle) */
        .label-group-top { transform: translate3d(240px, -60px, 130px) rotateZ(38deg) rotateX(-72deg); position: absolute; white-space: nowrap; }
        .label-group-mid { transform: translate3d(260px, 40px, 10px) rotateZ(38deg) rotateX(-72deg); position: absolute; white-space: nowrap; }
        .label-group-bot { transform: translate3d(280px, 130px, -110px) rotateZ(38deg) rotateX(-72deg); position: absolute; white-space: nowrap; }

        .guide-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 7px;
            color: rgba(255, 255, 255, 0.3);
            letter-spacing: 0.25em;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .guide-bracket {
            width: 120px;
            height: 1px;
            background: linear-gradient(90deg, rgba(255,255,255,0.2), transparent);
        }

        /* Subtle glow pulse on hover */
        .stack-layer:hover::after {
            animation: sidePulse 2.5s ease-in-out infinite;
        }

        @keyframes sidePulse {
            0%, 100% { opacity: 0.4; box-shadow: none; }
            50% { opacity: 0.7; box-shadow: inset 0 0 12px rgba(0, 255, 136, 0.15); }
        }

        #bg-canvas {
            position: absolute;
            top: 0; right: 0; width: 100%; height: 100%;
            z-index: 0;
        }

        footer {
            padding: 80px 40px 160px 40px;
            background: #050505;
            position: relative;
        }

        footer .grid-container { display: flex; align-items: center; justify-content: center; }
        footer .contact-inner { text-align: center; max-width: 900px; margin: 0 auto; }
        
        .contact-content-wrapper {
            padding: 40px 0 80px 0;
            margin: 0;
        }

        .contact-content h2 {
            font-family: 'JetBrains Mono', monospace;
            line-height: 0.9;
        }

        .contact-card:hover {
            border-color: rgba(0, 255, 136, 0.5);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.9),
                0 8px 32px rgba(0, 255, 136, 0.2),
                0 0 80px rgba(0, 255, 136, 0.1),
                inset 0 2px 2px rgba(255, 255, 255, 0.5),
                inset 0 -3px 6px rgba(0, 0, 0, 0.7);
            transform: translateY(-8px);
        }

        .contact-content h2 {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1;
            letter-spacing: -0.02em;
            margin-bottom: 16px;
            /* Plain high-contrast heading - remove gradient/shading */
            background: none !important;
            -webkit-background-clip: initial !important;
            -webkit-text-fill-color: initial !important;
            background-clip: initial !important;
            color: #fff;
            mix-blend-mode: normal;
            text-shadow: none;
        }

        .contact-content p {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #d4d4d4;
            margin: 20px 0;
        }

        .contact-cta-row { display:flex; gap:20px; align-items:center; justify-content:center; margin-top:40px; flex-wrap: wrap; }

        .btn-primary {
            padding: 16px 32px;
            background: linear-gradient(90deg, #00ff88, #00d18f);
            color: #012;
            font-weight: 700;
            font-size: 1rem;
            box-shadow: 0 8px 30px var(--accent-glow);
            border: none;
            transition: all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1);
            text-decoration: none;
            display:inline-flex;
            align-items:center;
            gap:10px;
            cursor: pointer;
        }
        .btn-primary:hover { 
            transform: translateY(-6px) scale(1.05);
            box-shadow: 0 16px 50px var(--accent-glow);
            opacity:0.95; 
        }

        .contact-btn { 
            display: inline-flex; 
            align-items:center; 
            justify-content:center; 
            width:100px; 
            height:100px; 
            background: transparent;
            border: none;
            transition: all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1); 
            color: var(--accent);
            position: relative;
        }
        .ico-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .contact-btn svg { 
            position: relative;
            z-index: 1;
            width:22px; 
            height:22px; 
            fill:currentColor; 
            transition: transform 0.4s ease;
        }
        .contact-btn:hover svg { 
            transform: scale(1.2) rotate(5deg);
        }

        @media (max-width: 768px) {
            .hero-title { font-size: 3rem; }
            .contact-card { padding: 40px 24px; }
            .contact-content h2 { font-size: 2.5rem; }
            .contact-cta-row { gap: 12px; }
        }

    </style>
</head>
<body>
    <div class="bg-noise"></div>

    <a href="#" class="site-logo" aria-label="Home">
        <canvas class="logo-canvas" width="36" height="36" aria-hidden="true"></canvas>
        <span class="logo-text mono">MIYANO</span>
    </a>

    <nav class="hud-nav" role="navigation" aria-label="Main menu">
        <a href="#" class="hud-link active">
            <div class="nav-bit"></div>
        </a>
        <a href="#work" class="hud-link">
            <div class="nav-bit"></div>
        </a>
        <a href="#process" class="hud-link">
            <div class="nav-bit"></div>
        </a>
        <a href="#contact" class="hud-link">
            <div class="nav-bit"></div>
        </a>
    </nav>

    <!-- Nav Cycle Arrow (Fallback) -->
    <div class="nav-arrows">
        <button id="nav-cycle" class="arrow-btn" aria-label="Next Section / Scroll to Top">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
        </button>
    </div>

    <main class="relative z-10">
        <!-- Hero -->
        <section class="hero-section">
            <div class="bg-hero-container">
                <div id="bg-canvas"></div>
                <div class="bg-vignette"></div>
            </div>
            <div class="grid-container w-full relative z-10 pointer-events-none">
                <div class="col-span-12 md:col-span-8 pointer-events-auto">
                    <div id="hero-copy" class="hero-copy">
                        <div class="badge mono" id="hero-badge" aria-hidden="true" style="display:none;"></div>
                        <h1 class="hero-title" id="hero-title">Designing complex products that improve operations, conversion and customer trust.</h1>
                        <p class="mt-6 text-neutral-200 max-w-xl text-lg leading-relaxed font-light" id="hero-sub">Senior UX Designer with 8 years of experience turning complex systems into clear, measurable product outcomes through strategy, interaction design and AI-assisted execution.</p>
                        <p class="mt-4 text-neutral-500 max-w-lg text-sm italic" id="hero-micro">From telecom and logistics to hospitality and fashion platforms.</p>

                        <div class="mt-6 flex flex-wrap gap-3 text-[11px] mono uppercase tracking-widest">
                            <span class="px-3 py-2 border border-white/15 bg-white/5 text-neutral-300">8+ Years Experience</span>
                            <span class="px-3 py-2 border border-white/15 bg-white/5 text-neutral-300">5 Live Case Studies</span>
                            <span class="px-3 py-2 border border-white/15 bg-white/5 text-neutral-300">B2B + B2C Domains</span>
                        </div>

                        <div class="mt-8 flex flex-wrap gap-3 items-center">
                            <a id="hero-cta" href="mailto:hello@miyano.net?subject=Project%20Inquiry" class="inline-block bg-white text-black px-6 py-3 font-bold text-sm uppercase tracking-wide hover:bg-neutral-200 transition-colors">BOOK INTRO CALL</a>
                            <a href="#work" class="inline-block border border-white/20 text-white px-6 py-3 font-bold text-sm uppercase tracking-wide hover:bg-white/5 transition-colors">SEE WORK ↓</a>
                        </div>

                    </div>
                </div>
            </div>
        </section>

        <!-- AI Practice Methodology -->
        <section id="ai-methodology" class="py-20 relative overflow-hidden" style="border-top: 1px solid var(--border);">
            <div class="grid-container">
                <!-- Header -->
                <div class="col-span-12 mb-16">
                    <div class="section-header-main">
                        <div class="header-tag">AI WORKFLOW</div>
                        <h2>Amplify outcomes,<br>not <span class="highlight">noise.</span></h2>
                        <div class="spec-list">
                            <div class="spec-item">Speed</div>
                            <div class="spec-item">Insight</div>
                            <div class="spec-item">Autonomy</div>
                        </div>
                    </div>
                </div>

                <!-- Grid System for Methods -->
                <div class="col-span-12 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 border-t border-l border-[var(--border)]">
                    
                    <!-- Item 1 -->
                    <div class="group relative p-8 border-b border-r border-[var(--border)] hover:bg-[var(--surface)] transition-colors duration-300">
                        <div class="mono text-[10px] text-[var(--accent)] mb-6 opacity-60">01 // VISUAL</div>
                        <h3 class="text-white text-lg font-medium mb-3">Behavior Simulation</h3>
                        <p class="text-neutral-500 text-sm leading-relaxed">
                            Generating artificial heatmaps to validate layout hypotheses before high-cost testing.
                        </p>
                    </div>

                    <!-- Item 2 -->
                    <div class="group relative p-8 border-b border-r border-[var(--border)] hover:bg-[var(--surface)] transition-colors duration-300">
                        <div class="mono text-[10px] text-[var(--accent)] mb-6 opacity-60">02 // SYNTHESIS</div>
                        <h3 class="text-white text-lg font-medium mb-3">Pattern Recognition</h3>
                        <p class="text-neutral-500 text-sm leading-relaxed">
                            Accelerating research analysis to find hidden insights—without replacing human judgment.
                        </p>
                    </div>

                    <!-- Item 3 -->
                    <div class="group relative p-8 border-b border-r border-[var(--border)] hover:bg-[var(--surface)] transition-colors duration-300">
                        <div class="mono text-[10px] text-[var(--accent)] mb-6 opacity-60">03 // PROTOTYPE</div>
                        <h3 class="text-white text-lg font-medium mb-3">Coding Models</h3>
                        <p class="text-neutral-500 text-sm leading-relaxed">
                            Building fully functional prototypes to test real logic and complex interactions, not just clicks.
                        </p>
                    </div>

                    <!-- Item 4 -->
                    <div class="group relative p-8 border-b border-r border-[var(--border)] hover:bg-[var(--surface)] transition-colors duration-300">
                        <div class="mono text-[10px] text-[var(--accent)] mb-6 opacity-60">04 // STRATEGY</div>
                        <h3 class="text-white text-lg font-medium mb-3">Operational Speed</h3>
                        <p class="text-neutral-500 text-sm leading-relaxed">
                            Automating "chore" tasks to maximize time for stakeholder alignment and creative decisions.
                        </p>
                    </div>

                </div>
                
                <!-- Quote / Footer of Section -->
                <div class="col-span-12 mt-12 text-center">
                    <p class="text-neutral-500 font-light italic text-sm max-w-2xl mx-auto">
                        "AI doesn’t replace design thinking — it removes the noise so better decisions can happen faster."
                    </p>
                </div>
            </div>
        </section>

        <!-- Projects -->
        <section id="work" class="py-20 relative overflow-hidden">
            <div class="max-w-[1400px] mx-auto px-8">
                <div class="section-header-main">
                    <div class="header-tag">SELECTED CASES</div>
                    <h2>Logic-driven interfaces<br>built for <span class="highlight">scalability.</span></h2>
                    <div class="spec-list">
                        <div class="spec-item">Systemic UX</div>
                        <div class="spec-item">Strategy</div>
                        <div class="spec-item">05 Solutions</div>
                    </div>
                </div>

                <!-- Bento Grid -->
                <div class="work-bento">
                    <!-- Featured: Algar (Large) -->
                    <article class="work-card featured" data-index="01">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(0,255,136,0.1), rgba(5,5,5,0.8)), url('assets/algar/thumb.svg'); background-position: center 25%; background-size: cover; z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="phone" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/algar.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">01</div>
                            <div class="card-content">
                                <span class="card-meta">Telecom / UX Performance</span>
                                <h3 class="card-title">ALGAR TELECOM</h3>
                                <div class="card-tags">
                                    <span class="card-tag">Complex Flows</span>
                                    <span class="card-tag">Legacy Systems</span>
                                    <span class="card-tag">Optimization</span>
                                </div>
                                <p class="card-excerpt">Redesigning critical flows in legacy systems to reduce friction and eliminate support tickets.</p>
                                <div class="card-metrics">
                                    <div class="metric">
                                        <span class="metric-value">1.9 → 3.0</span>
                                        <span class="metric-label">App Rating</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">-42%</span>
                                        <span class="metric-label">Support Tickets</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Volpi (Medium) -->
                    <article class="work-card medium" data-index="02">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(15,5,25,0.92), rgba(5,5,5,0.88)), url('assets/volpi/thumb.svg'); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="building" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/volpi.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">02</div>
                            <div class="card-content">
                                <span class="card-meta">Fintech / Strategy</span>
                                <h3 class="card-title">VOLPI</h3>
                                <div class="card-tags">
                                    <span class="card-tag">High Scale</span>
                                    <span class="card-tag">Regulated Product</span>
                                    <span class="card-tag">0→1</span>
                                </div>
                                <p class="card-excerpt">Simplifying complex regulations into a transparent onboarding journey for digital mortgages.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">-40%</span>
                                        <span class="metric-label">Process Time</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">+35%</span>
                                        <span class="metric-label">Conversion</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Torre (Medium) -->
                    <article class="work-card medium" data-index="03">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(20,10,5,0.92), rgba(5,5,5,0.88)), url('assets/torre/flow-1.svg'); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="truck" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/torre-controle.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">03</div>
                            <div class="card-content">
                                <span class="card-meta">Logistics / B2B</span>
                                <h3 class="card-title">TORRE DE CONTROLE</h3>
                                <div class="card-tags">
                                    <span class="card-tag">Complex Flows</span>
                                    <span class="card-tag">B2B</span>
                                    <span class="card-tag">Workflow Automation</span>
                                </div>
                                <p class="card-excerpt">Optimizing visibility and automating workflows for high-volume logistics command centers.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">-30%</span>
                                        <span class="metric-label">MTTR</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">50%</span>
                                        <span class="metric-label">Auto-routed</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Sistema de Pistas (Medium) -->
                    <article class="work-card medium" data-index="04">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(5,25,16,0.92), rgba(5,5,5,0.88)); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="phone" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/sistema-pistas-boliche.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">04</div>
                            <div class="card-content">
                                <span class="card-meta">Hospitality / Operations</span>
                                <h3 class="card-title">SISTEMA DE PISTAS</h3>
                                <div class="card-tags">
                                    <span class="card-tag">Agenda</span>
                                    <span class="card-tag">Check-in</span>
                                    <span class="card-tag">Comandas</span>
                                </div>
                                <p class="card-excerpt">Unifying waiting list, lane allocation, check-in and consumption flow for bowling center operations.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">+Visibilidade</span>
                                        <span class="metric-label">Operação</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">-Atrito</span>
                                        <span class="metric-label">Atendimento</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>

                    <!-- Fashion Catalog (Medium) -->
                    <article class="work-card medium" data-index="05">
                        <div class="card-bg" style="background-image: linear-gradient(135deg, rgba(25,10,16,0.92), rgba(5,5,5,0.88)); z-index: 1;"></div>
                        <canvas class="card-3d-viz" data-shape="building" style="position: absolute; inset: 0; z-index: 5; pointer-events: none;"></canvas>
                        <a href="cases/fashion-store-catalog.html" class="card-link" style="position: relative; z-index: 10;">
                            <div class="card-index">05</div>
                            <div class="card-content">
                                <span class="card-meta">E-commerce / Catalog Platform</span>
                                <h3 class="card-title">FASHION CATALOG</h3>
                                <div class="card-tags">
                                    <span class="card-tag">Search</span>
                                    <span class="card-tag">Collections</span>
                                    <span class="card-tag">Admin</span>
                                </div>
                                <p class="card-excerpt">Scalable fashion catalog architecture connecting public discovery experiences with admin workflows.</p>
                                <div class="card-metrics compact">
                                    <div class="metric">
                                        <span class="metric-value">+Agilidade</span>
                                        <span class="metric-label">Curadoria</span>
                                    </div>
                                    <div class="metric">
                                        <span class="metric-value">+Consistência</span>
                                        <span class="metric-label">Dados</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card-cta">
                                <span class="cta-text">View case</span>
                                <span class="cta-arrow">→</span>
                            </div>
                        </a>
                    </article>
                </div>
            </div>
        </section>



        <!-- UX Strategy / Capabilities -->
        <section id="process" class="py-20 bg-[#050505] overflow-hidden relative">
            
            <div class="max-w-[1400px] mx-auto px-8 relative z-10">
                <!-- Header: Title spanning full width -->
                <div class="section-header-main">
                    <div class="header-tag">CAPABILITIES</div>
                    <h2>Systems Thinking<br>for <span class="highlight">UX.</span></h2>
                    <div class="spec-list">
                        <div class="spec-item">Strategy</div>
                        <div class="spec-item">Execution</div>
                        <div class="spec-item">Impact</div>
                    </div>
                </div>

                <div class="grid-container !px-0 items-center">
                    <!-- Left: Process Steps (Centered gap: Starts at col 3) -->
                    <div class="col-span-12 lg:col-start-3 lg:col-span-4 flex flex-col pr-8">
                        <div class="process-list space-y-10">
                            <div class="process-step group" data-step="1">
                                <div class="flex items-start gap-4">
                                    <span class="mono text-[11px] text-accent font-bold mt-1.5">01 //</span>
                                    <div>
                                        <h3 class="text-xl font-medium mb-2 group-hover:text-white transition-colors">Strategic Foundation</h3>
                                        <p class="text-neutral-400 text-sm leading-relaxed max-w-xs group-hover:text-neutral-200 transition-colors">
                                            Aligning user needs with business goals through research and framing.
                                        </p>
                                    </div>
                                </div>
                            </div>

                            <div class="process-step group" data-step="2">
                                <div class="flex items-start gap-4">
                                    <span class="mono text-[11px] text-accent font-bold mt-1.5">02 //</span>
                                    <div>
                                        <h3 class="text-xl font-medium mb-2 group-hover:text-white transition-colors">Technical Execution</h3>
                                        <p class="text-neutral-400 text-sm leading-relaxed max-w-xs group-hover:text-neutral-200 transition-colors">
                                            Translating strategy into interactive systems and design delivery.
                                        </p>
                                    </div>
                                </div>
                            </div>

                            <div class="process-step group" data-step="3">
                                <div class="flex items-start gap-4">
                                    <span class="mono text-[11px] text-accent font-bold mt-1.5">03 //</span>
                                    <div>
                                        <h3 class="text-xl font-medium mb-2 group-hover:text-white transition-colors">Measurable Impact</h3>
                                        <p class="text-neutral-400 text-sm leading-relaxed max-w-xs group-hover:text-neutral-200 transition-colors">
                                            Validating results through rigorous user testing and performance data.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right: 3D Exploded Stack (Offset slightly right) -->
                    <div class="col-span-12 lg:col-span-4 relative flex items-center justify-center stack-container lg:translate-x-8">
                        <div class="stack-visual w-full">
                        <div class="stack-layers" id="stack-layers">
                            <!-- Group Labels (Bottom Layer helps position these) -->
                            <div class="label-group-top"><div class="guide-label">STRATEGIC_CORE</div><div class="guide-bracket"></div></div>
                            <div class="label-group-mid"><div class="guide-label">TECHNICAL_LOGIC</div><div class="guide-bracket"></div></div>
                            <div class="label-group-bot"><div class="guide-label">SYSTEM_ORCHESTRATION</div><div class="guide-bracket"></div></div>

                            <!-- Layers reordered Top-Down for Process Flow: Research (Top) -> Impact (Bottom) -->
                            
                            <!-- Layer 1: Measurable Impact (BOTTOM) -->
                            <div class="stack-layer layer-1" data-label="Measurable Impact">
                                <div class="stack-layer-back"></div><div class="stack-layer-left"></div>
                                <div class="layer-inner">
                                    <svg class="layer-wire" viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="35" stroke-dasharray="2 4" />
                                        <path d="M30 60 L45 40 L60 50 L75 30" stroke-width="1" stroke="var(--accent)" />
                                    </svg>
                                </div>
                            </div>

                            <!-- Layer 2: Design Systems -->
                            <div class="stack-layer layer-2" data-label="Design Systems & Delivery">
                                <div class="stack-layer-back"></div><div class="stack-layer-left"></div>
                                <div class="layer-inner">
                                    <svg class="layer-wire" viewBox="0 0 100 100">
                                        <rect x="20" y="20" width="15" height="15" />
                                        <rect x="42.5" y="20" width="15" height="15" />
                                        <rect x="65" y="20" width="15" height="15" />
                                        <rect x="20" y="42.5" width="15" height="15" />
                                        <rect x="42.5" y="42.5" width="15" height="15" />
                                        <rect x="20" y="65" width="15" height="15" />
                                    </svg>
                                </div>
                            </div>

                            <!-- Layer 3: Prototyping -->
                            <div class="stack-layer layer-3" data-label="Prototyping & Validation">
                                <div class="stack-layer-back"></div><div class="stack-layer-left"></div>
                                <div class="layer-inner">
                                    <svg class="layer-wire" viewBox="0 0 100 100">
                                        <circle cx="25" cy="25" r="4" stroke-width="0.5" />
                                        <circle cx="75" cy="25" r="4" stroke-width="0.5" />
                                        <circle cx="50" cy="50" r="10" stroke-width="1" />
                                        <circle cx="25" cy="75" r="4" stroke-width="0.5" />
                                        <circle cx="75" cy="75" r="4" stroke-width="0.5" />
                                        <path d="M29 29 L41 41 M71 29 L59 41 M29 71 L41 59 M71 71 L59 59" opacity="0.4" stroke-width="0.5" />
                                    </svg>
                                </div>
                            </div>

                            <!-- Layer 4: Interaction (HIGHLIGHT) -->
                            <div class="stack-layer layer-4 layer-highlight" data-label="Interaction Design">
                                <div class="stack-layer-back"></div><div class="stack-layer-left"></div>
                                <div class="layer-inner">
                                    <div class="absolute inset-0 bg-[radial-gradient(circle_at_center,rgba(0,255,136,0.1),transparent_70%)]"></div>
                                    <svg class="layer-wire" viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="20" stroke="var(--accent)" stroke-width="1.5" />
                                        <circle cx="50" cy="50" r="35" stroke-dasharray="4 4" opacity="0.6" />
                                        <path d="M10 50 L90 50" stroke="var(--accent)" stroke-width="0.2" opacity="0.4" />
                                    </svg>
                                </div>
                            </div>

                            <!-- Layer 5: Strategy -->
                            <div class="stack-layer layer-5" data-label="Strategy">
                                <div class="stack-layer-back"></div><div class="stack-layer-left"></div>
                                <div class="layer-inner">
                                    <svg class="layer-wire" viewBox="0 0 100 100">
                                        <path d="M50 20 L80 80 L20 80 Z" stroke-width="0.5" />
                                        <circle cx="50" cy="50" r="10" opacity="0.3" />
                                    </svg>
                                </div>
                            </div>

                            <!-- Layer 6: Framing -->
                            <div class="stack-layer layer-6" data-label="Problem Framing">
                                <div class="stack-layer-back"></div><div class="stack-layer-left"></div>
                                <div class="layer-inner">
                                    <svg class="layer-wire" viewBox="0 0 100 100">
                                        <rect x="25" y="25" width="50" height="50" stroke-width="0.5" />
                                        <path d="M25 25 L75 75 M75 25 L25 75" opacity="0.3" />
                                    </svg>
                                </div>
                            </div>

                            <!-- Layer 7: Research (TOP) -->
                            <div class="stack-layer layer-7" data-label="User Research & Insights">
                                <div class="stack-layer-back"></div><div class="stack-layer-left"></div>
                                <div class="layer-inner">
                                    <svg class="layer-wire" viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="40" stroke-width="0.5" />
                                        <circle cx="50" cy="50" r="2" fill="white" />
                                        <path d="M50 10 L50 90 M10 50 L90 50" opacity="0.2" />
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Contact/Footer -->
        <footer id="contact" class="relative overflow-hidden">
            <div class="bg-hero-container">
                <canvas id="bg-wave-canvas"></canvas>
                <div class="bg-vignette"></div>
            </div>
            <div class="grid-container relative z-10">
                <div class="col-span-12 contact-inner">
                    <div class="contact-content-wrapper">
                        <div class="contact-content">
                            <div class="section-header-main">
                                <div class="header-tag">CONTACT</div>
                                <h2>LET'S BUILD SOMETHING USEFUL</h2>
                                <p class="text-xl text-neutral-300 max-w-2xl mx-auto mb-4">Have an idea? Let's chat.</p>
                            </div>
                        </div>

                        <div class="contact-cta-row mt-12">
                            <a href="https://www.linkedin.com/in/miyano/" class="contact-btn ico-btn" aria-label="LinkedIn" target="_blank" rel="noopener noreferrer" title="LINKEDIN">
                                <canvas class="ico-canvas"></canvas>
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4.98 3.5C4.98 4.88 3.86 6 2.5 6S0 4.88 0 3.5 1.12 1 2.5 1 4.98 2.12 4.98 3.5zM0 8.99h5V24H0V8.99zM8.5 8.99h4.78v2.07h.07c.67-1.27 2.3-2.61 4.74-2.61 5.07 0 6 3.34 6 7.68V24h-5v-7.52c0-1.79-.03-4.09-2.49-4.09-2.49 0-2.87 1.94-2.87 3.96V24h-5V8.99z"/></svg>
                            </a>
                            <a href="mailto:hello@miyano.net" class="contact-btn ico-btn" aria-label="Email">
                                <canvas class="ico-canvas"></canvas>
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z" fill="currentColor"/></svg>
                            </a>
                        </div>
                    </div>

                    <div style="margin-top: 60px; padding-top: 40px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                        <p class="mono text-[10px] text-neutral-600 mb-2">© 2026 Miyano Bot.</p>
                        <p class="mono text-xs opacity-40">Designed by me. Built with AI-assisted development.</p>
                    </div>
                </div>
            </div>
        </footer>
    </main>

    <script>
        // Dynamic Nav - Constellation Logic
        const nav = document.querySelector('.hud-nav');
        const navLinks = Array.from(document.querySelectorAll('.hud-link'));
        let ticking = false;

        // Entrance effects
        navLinks.forEach((link, i) => {
            setTimeout(() => {
                link.style.opacity = '1';
                link.style.transform = 'translate(0, 0)';
            }, 300 * i);
        });

        // Section Observer for Active Navigation
        const observerOptions = {
            threshold: 0.2 // lowered threshold for scattered dots
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    navLinks.forEach(link => {
                        const href = link.getAttribute('href');
                        link.classList.toggle('active', 
                            (href === '#' + id) || 
                            (href === '#' && (entry.target.tagName === 'SECTION' && entry.target.previousElementSibling === null)) ||
                            (href === '#' && entry.target.closest('.hero-section'))
                        );
                    });
                }
            });
        }, observerOptions);

        // Observe all logical landing points
        const observerSections = document.querySelectorAll('section[id], footer[id], .hero-section');
        observerSections.forEach(el => {
            observer.observe(el);
        });

        // Arrow Cycle Logic
        const sectionsArr = Array.from(observerSections);
        const cycleBtn = document.getElementById('nav-cycle');

        function updateArrowState() {
            if (!cycleBtn) return;
            const isAtEnd = (window.innerHeight + window.scrollY) >= document.documentElement.scrollHeight - 100;
            if (isAtEnd) {
                cycleBtn.classList.add('is-end');
            } else {
                cycleBtn.classList.remove('is-end');
            }
        }
        window.addEventListener('scroll', updateArrowState, { passive: true });

        function navigateCycle() {
            const isAtEnd = (window.innerHeight + window.scrollY) >= document.documentElement.scrollHeight - 100;
            
            if (isAtEnd) {
                window.scrollTo({ top: 0, behavior: 'smooth' });
                return;
            }

            let currentIndex = -1;
            const center = window.scrollY + (window.innerHeight / 2);

            sectionsArr.forEach((sec, i) => {
                const rect = sec.getBoundingClientRect();
                const top = rect.top + window.scrollY;
                if (center >= top && center <= top + rect.height) {
                    currentIndex = i;
                }
            });

            const nextIndex = currentIndex + 1;
            if (nextIndex < sectionsArr.length) {
                sectionsArr[nextIndex].scrollIntoView({ behavior: 'smooth' });
            } else {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        if (cycleBtn) cycleBtn.addEventListener('click', navigateCycle);
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'https://unpkg.com/three@0.128.0/examples/jsm/geometries/RoundedBoxGeometry.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
        import { MeshSurfaceSampler } from 'https://unpkg.com/three@0.128.0/examples/jsm/math/MeshSurfaceSampler.js';

        // Audio Engine (keeping in module scope or attaching to window)
        window.AUDIO = {
            ctx: null,
            init() { 
                if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            },
            play(freq) {
                this.init();
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                o.frequency.value = freq;
                o.type = 'sine';
                g.gain.setValueAtTime(0.02, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                o.connect(g);
                g.connect(this.ctx.destination);
                o.start();
                o.stop(this.ctx.currentTime + 0.1);
            }
        };

        // UI Interactions
        document.querySelectorAll('a, .work-card').forEach(el => {
            el.addEventListener('mouseenter', () => window.AUDIO.play(2000));
        });

        // 3D Particle Visualizations on Work Cards
        (function init3DViz() {
            console.log('Initializing 3D visualizations...');
            // Global sampling probability: increased for denser, more refined point clouds
            const SAMPLE_RATE = 0.45;

            // Improved stratified sampler with better distribution and more points per cell
            function stratifiedSample(candidates, cellSize, sampleRate, minPerCell = 2, maxTotal = 12000) {
                const cells = new Map();
                for (const p of candidates) {
                    const cx = Math.floor(p[0] / cellSize);
                    const cy = Math.floor(p[1] / cellSize);
                    const cz = Math.floor(p[2] / cellSize);
                    const key = `${cx}|${cy}|${cz}`;
                    if (!cells.has(key)) cells.set(key, []);
                    cells.get(key).push(p);
                }
                const result = [];
                for (const pts of cells.values()) {
                    // Increased minimum points per cell for uniform coverage
                    const k = Math.max(minPerCell, Math.round(sampleRate * pts.length));
                    // Fisher-Yates shuffle for better randomization
                    for (let i = pts.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [pts[i], pts[j]] = [pts[j], pts[i]];
                    }
                    const take = Math.min(k, pts.length);
                    for (let i = 0; i < take; i++) result.push(pts[i]);
                    if (result.length >= maxTotal) break;
                }
                // Uniform sampling down if needed
                if (result.length > maxTotal) {
                    for (let i = result.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [result[i], result[j]] = [result[j], result[i]];
                    }
                    return result.slice(0, maxTotal);
                }
                return result;
            }
            
            // Helper: Generate phone shape as 3D points
            function generatePhonePoints() {
                const candidates = [];
                const w = 70, h = 140, d = 10, r = 12;
                // Aggressive low spacing for testing
                const density = 1.0;
                
                // Front and Back faces with rounded corners
                for (let x = -w/2; x <= w/2; x += density) {
                    for (let y = -h/2; y <= h/2; y += density) {
                        const dx = Math.abs(x) - (w/2 - r);
                        const dy = Math.abs(y) - (h/2 - r);
                        let inside = false;
                        if (dx <= 0 || dy <= 0) inside = true;
                        else if (dx * dx + dy * dy <= r * r) inside = true;

                        if (inside) {
                            // Bezel vs Screen logic
                            const margin = 4;
                            const isScreen = Math.abs(x) < (w/2 - margin) && Math.abs(y) < (h/2 - margin);
                            
                            // Front face (Screen has higher density)
                            if (isScreen) {
                                // Dynamic Island cutout
                                const isIsland = Math.abs(x) < 12 && y > h/2 - 15 && y < h/2 - 10;
                                if (!isIsland) candidates.push([x, y, d/2]);
                            } else {
                                // Reduce bezel density with sampling
                                if (Math.random() < SAMPLE_RATE) candidates.push([x, y, d/2]);
                            }

                            // Back face
                            const isCameraBump = x < -w/2 + 30 && y > h/2 - 40;
                            if (isCameraBump) {
                                candidates.push([x, y, -d/2 - 2]); // Camera bump sticking out
                                // Lenses
                                const l1 = Math.pow(x - (-w/2 + 12), 2) + Math.pow(y - (h/2 - 12), 2) < 16;
                                const l2 = Math.pow(x - (-w/2 + 12), 2) + Math.pow(y - (h/2 - 28), 2) < 16;
                                if (l1 || l2) candidates.push([x, y, -d/2 - 4]);
                            } else {
                                // Algar Logo on the back
                                const logoX = 0, logoY = -10, logoSize = 15;
                                const distFromLogoCenter = Math.sqrt(Math.pow(x - logoX, 2) + Math.pow(y - logoY, 2));
                                const isLogo = distFromLogoCenter < logoSize && distFromLogoCenter > logoSize - 3;
                                const isLogoInner = Math.abs(x) < 2 && Math.abs(y - logoY) < logoSize;
                                
                                if (isLogo || isLogoInner) {
                                    candidates.push([x, y, -d/2 - 1.5]);
                                } else {
                                    if (Math.random() < SAMPLE_RATE) candidates.push([x, y, -d/2]);
                                }
                            }
                        }
                    }
                }
                
                // Sides/Edges
                for (let y = -h/2; y <= h/2; y += density * 1.5) {
                    const dy = Math.abs(y) - (h/2 - r);
                    const curX = dy > 0 ? (w/2 - r) + Math.sqrt(Math.max(0, r*r - dy*dy)) : w/2;
                    for (let z = -d/2; z <= d/2; z += density) {
                        // sample edges sparsely
                        if (Math.random() < SAMPLE_RATE) {
                            candidates.push([curX, y, z]);
                            candidates.push([-curX, y, z]);
                        }
                    }
                }
                
                // Stratified sampling to avoid holes
                return stratifiedSample(candidates, density, SAMPLE_RATE, 1, 2000);
            }
            
            // Helper: Generate realistic house shape
            function generateBuildingPoints() {
                const candidates = [];
                // Aggressive low spacing for testing
                const density = 1.0;
                
                const drawStructure = (xOff, yOff, zOff, w, h, d, hasRoof = true) => {
                    for (let x = -w/2; x <= w/2; x += density) {
                        for (let y = -h/2; y <= h/2; y += density) {
                            for (let z = -d/2; z <= d/2; z += density) {
                                const isSurface = Math.abs(x - w/2) < 1 || Math.abs(x + w/2) < 1 || 
                                                 Math.abs(y - h/2) < 1 || Math.abs(y + h/2) < 1 || 
                                                 Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1;
                                if (isSurface) {
                                    // Main Door
                                    const isFront = Math.abs(z - d/2) < 1 && xOff === 0;
                                    const isDoor = isFront && Math.abs(x) < 8 && y < -5;
                                    if (isDoor) continue;
                                    
                                    // Windows
                                    const isWindow = (Math.abs(x) % 30 > 8 && Math.abs(x) % 30 < 22 && Math.abs(y) < 10);
                                    if (isWindow && !isDoor) continue;

                                    if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, y + yOff, z + zOff]);
                                }
                            }
                        }
                    }
                    if (hasRoof) {
                        const roofH = 35;
                        for (let z = -d/2 - 4; z <= d/2 + 4; z += density) {
                            for (let x = -w/2 - 4; x <= w/2 + 4; x += density) {
                                const ry = h/2 + roofH * (1 - Math.abs(x) / (w/2 + 4));
                                if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, ry + yOff, z + zOff]);
                                if (Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1) {
                                    for (let gy = h/2; gy < ry; gy += density) {
                                        if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, gy + yOff, z + zOff]);
                                    }
                                }
                            }
                        }
                    }
                };

                drawStructure(0, -10, 0, 70, 50, 60, true);  // Main House
                drawStructure(50, -20, 5, 35, 35, 45, true); // Side wing
                
                // Chimney
                for (let x = -25; x < -15; x += density) {
                    for (let z = -25; z < -15; z += density) {
                        for (let y = 10; y < 65; y += density) {
                            candidates.push([x, y, z]);
                        }
                    }
                }
                
                // Stratified sampling to avoid holes
                return stratifiedSample(candidates, density, SAMPLE_RATE, 1, 3000);
            }
            
            // Helper: Generate realistic semi-truck shape
            function generateTruckPoints() {
                const candidates = [];
                // Aggressive low spacing for testing
                const density = 1.0;
                
                const drawPart = (xOff, yOff, zOff, w, h, d, options = {}) => {
                    for (let x = -w/2; x <= w/2; x += density) {
                        for (let y = -h/2; y <= h/2; y += density) {
                            for (let z = -d/2; z <= d/2; z += density) {
                                const isSurface = Math.abs(x - w/2) < 1 || Math.abs(x + w/2) < 1 || 
                                                 Math.abs(y - h/2) < 1 || Math.abs(y + h/2) < 1 || 
                                                 Math.abs(z - d/2) < 1 || Math.abs(z + d/2) < 1;
                                if (isSurface) {
                                    // Window cutout logic
                                    if (options.isCab && x < -w/2 + 2 && Math.abs(z) < d/2 - 4 && y > 0) {
                                        if (Math.abs(z) > d/2 - 6 || y > h/2 - 3) candidates.push([x + xOff, y + yOff, z + zOff]);
                                        continue;
                                    }
                                    if (Math.random() < SAMPLE_RATE) candidates.push([x + xOff, y + yOff, z + zOff]);
                                }
                            }
                        }
                    }
                };

                // Cab
                drawPart(-45, -5, 0, 35, 50, 38, { isCab: true });
// Mirrors (sparser)
                [1, -1].forEach(side => {
                    for (let y = 0; y < 15; y += 5) {
                        if (Math.random() < SAMPLE_RATE) candidates.push([-58, y, side * 22]);
                    }
                });
                // Exhausts (sparser)
                for (let y = -10; y < 45; y += 6) {
                    if (Math.random() < SAMPLE_RATE) candidates.push([-30, y, 16], [-30, y, -16]);
                }

                // Cargo Trailer
                drawPart(25, 5, 0, 100, 65, 42);
                
                // Chassis and Fuel Tanks (sparser)
                for (let x = -60; x < 65; x += 8) {
                    if (Math.random() < SAMPLE_RATE) candidates.push([x, -25, 12], [x, -25, -12]);
                    if (x > -35 && x < -15) {
                        for (let angle = 0; angle < Math.PI * 2; angle += 1.0) {
                            if (Math.random() < SAMPLE_RATE) candidates.push([x, -22 + Math.cos(angle)*8, 22 + Math.sin(angle)*8]);
                            if (Math.random() < SAMPLE_RATE) candidates.push([x, -22 + Math.cos(angle)*8, -22 - Math.sin(angle)*8]);
                        }
                    }
                }
                
                // 4 Wheels (sparser dz and angle steps)
                const wheelPos = [[-55, -30], [50, -30]];
                wheelPos.forEach(([wx, wy]) => {
                    for (let side = -1; side <= 1; side += 2) {
                        const zCenter = side * 24;
                        for (let dz = -5; dz <= 5; dz += 4) {
                            for (let angle = 0; angle < Math.PI * 2; angle += 0.8) {
                                const r = 13;
                                if (Math.random() < SAMPLE_RATE) candidates.push([wx + Math.cos(angle) * r, wy + Math.sin(angle) * r, zCenter + dz]);
                            }
                        }
                    }
                });
                
                // Stratified sampling to avoid holes
                return stratifiedSample(candidates, density, SAMPLE_RATE, 1, 3500);
            }
            
            // Create Three.js scene for each canvas
            document.querySelectorAll('.card-3d-viz').forEach(canvas => {
                const shape = canvas.dataset.shape;
                const container = canvas.parentElement;

                const initViz = (w, h) => {
                    if (canvas.dataset.loaded === "true") return;
                    canvas.dataset.loaded = "true";
                    
                    try {
                        console.log(`Initializing ${shape} viz: ${w}x${h}`);
                        const scene = new THREE.Scene();
                        const camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 2000);
                        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
                        
                        renderer.setPixelRatio(window.devicePixelRatio || 1);
                        renderer.setSize(w, h);
                        camera.position.z = 250;

                        // Mapping shapes to GLB files
                        const glbMap = {
                            'phone': 'Phone.glb',
                            'building': 'Farm house.glb',
                            'truck': 'Truck.glb'
                        };

                        let object3D = null;
                        const glbFile = glbMap[shape];

                        if (glbFile) {
                            const loader = new GLTFLoader();
                            loader.load(glbFile, (gltf) => {
                                const model = gltf.scene || gltf.scenes[0];
                                
                                // 1. Normalize model scale BEFORE sampling to ensure grid consistency
                                const box = new THREE.Box3().setFromObject(model);
                                const size = new THREE.Vector3(); box.getSize(size);
                                const maxDim = Math.max(size.x, size.y, size.z);
                                const preScale = 160 / maxDim; // Reduced by 20% (was 200)
                                model.scale.setScalar(preScale);
                                model.updateMatrixWorld(true);
                                
                                // 2. Create Voxel-style Dotted Grid (Clean Technical)
                                const group = new THREE.Group();
                                const pointsArr = [];
                                const gridSet = new Set();
                                const gridSize = shape === 'phone' ? 1.6 : 2.0;
                                
                                model.traverse(c => {
                                    if (c.isMesh && c.geometry) {
                                        // 2a. Surface Points (Snapping to a 3D grid for a clean "dotted grid" feel)
                                        const sampler = new MeshSurfaceSampler(c).build();
                                        const tempPos = new THREE.Vector3();
                                        const box = new THREE.Box3().setFromObject(c);
                                        const size = new THREE.Vector3(); box.getSize(size);
                                        const area = (size.x * size.y + size.x * size.z + size.y * size.z) * 2;
                                        // Massive increase in sample pool for a "solid" light look
                                        const sampleCount = Math.min(60000, 80 * area);

                                        for (let i = 0; i < sampleCount; i++) {
                                            sampler.sample(tempPos);
                                            tempPos.applyMatrix4(c.matrixWorld);
                                            
                                            // Precise grid snapping
                                            const gx = Math.round(tempPos.x / gridSize) * gridSize;
                                            const gy = Math.round(tempPos.y / gridSize) * gridSize;
                                            const gz = Math.round(tempPos.z / gridSize) * gridSize;
                                            
                                            const key = `${gx.toFixed(1)}|${gy.toFixed(1)}|${gz.toFixed(1)}`;
                                            if (!gridSet.has(key)) {
                                                gridSet.add(key);
                                                pointsArr.push(gx, gy, gz);
                                            }
                                        }

                                        // 2b. Edge Interpolation (Ensuring outlines are also dotted grids)
                                        const edges = new THREE.EdgesGeometry(c.geometry, 25);
                                        const posAttr = edges.attributes.position;
                                        for (let i = 0; i < posAttr.count; i += 2) {
                                            const v1 = new THREE.Vector3().fromBufferAttribute(posAttr, i).applyMatrix4(c.matrixWorld);
                                            const v2 = new THREE.Vector3().fromBufferAttribute(posAttr, i + 1).applyMatrix4(c.matrixWorld);
                                            const dist = v1.distanceTo(v2);
                                            const steps = Math.ceil(dist / gridSize);
                                            for (let s = 0; s <= steps; s++) {
                                                const t = s / steps;
                                                const px = v1.x + (v2.x - v1.x) * t;
                                                const py = v1.y + (v2.y - v1.y) * t;
                                                const pz = v1.z + (v2.z - v1.z) * t;
                                                
                                                const gx = Math.round(px / gridSize) * gridSize;
                                                const gy = Math.round(py / gridSize) * gridSize;
                                                const gz = Math.round(pz / gridSize) * gridSize;
                                                
                                                const key = `${gx.toFixed(1)}|${gy.toFixed(1)}|${gz.toFixed(1)}`;
                                                if (!gridSet.has(key)) {
                                                    gridSet.add(key);
                                                    pointsArr.push(gx, gy, gz);
                                                }
                                            }
                                        }
                                    }
                                });

                                const geo = new THREE.BufferGeometry();
                                geo.setAttribute('position', new THREE.Float32BufferAttribute(pointsArr, 3));
                                
                                // Create a radiant circular dot texture
                                const dotCanvas = document.createElement('canvas');
                                dotCanvas.width = 64; dotCanvas.height = 64;
                                const dotCtx = dotCanvas.getContext('2d');
                                const grad = dotCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
                                grad.addColorStop(0, 'rgba(255, 255, 255, 1)'); // Sharp center
                                grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
                                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');  // Soft edge glow
                                dotCtx.fillStyle = grad;
                                dotCtx.fillRect(0, 0, 64, 64);
                                const dotTex = new THREE.CanvasTexture(dotCanvas);

                                const ptsMat = new THREE.PointsMaterial({
                                    color: 0x44ffaa, // Brighter, whiter mint
                                    size: 1.8,
                                    map: dotTex,
                                    transparent: true,
                                    opacity: 1.0,
                                    blending: THREE.AdditiveBlending,
                                    depthWrite: false,
                                    depthTest: false, // Allows all points to shine through, massively increasing brightness
                                    sizeAttenuation: true
                                });

                                const finalPts = new THREE.Points(geo, ptsMat);
                                group.add(finalPts);

                                // Center the entire group
                                const centerBox = new THREE.Box3().setFromObject(group);
                                const center = new THREE.Vector3(); centerBox.getCenter(center);
                                group.position.sub(center);

                                // Final normalization
                                const finalScale = shape === 'phone' ? 0.9 : 1.1; 
                                group.scale.setScalar(finalScale);

                                // Adjust starting orientation
                                if (shape === 'phone') {
                                    group.rotation.y = Math.PI;
                                } else if (shape === 'truck') {
                                    group.rotation.y = -Math.PI * 0.25; // Isometric front-left facing
                                } else {
                                    group.rotation.y = Math.PI * -0.2;
                                }
                                
                                scene.add(group);
                                object3D = group;
                            }, undefined, (err) => {
                                console.error('GLTF load error', err);
                                // Fallback to procedural if GLB fails
                                loadFallback(shape, scene, (pts) => { object3D = pts; });
                            });

                            let rotX = 0.3, rotY;
                            if (shape === 'phone') rotY = Math.PI;
                            else if (shape === 'truck') rotY = -Math.PI * 0.25;
                            else rotY = 0.5;

                            let targetRotX = rotX, targetRotY = rotY;

                            container.addEventListener('mousemove', (e) => {
                                const rect = container.getBoundingClientRect();
                                const mouseX = ((e.clientX - rect.left) / w - 0.5) * Math.PI;
                                const mouseY = ((e.clientY - rect.top) / h - 0.5) * Math.PI * 0.5;
                                
                                if (shape === 'phone') targetRotY = Math.PI + mouseX;
                                else if (shape === 'truck') targetRotY = (-Math.PI * 0.25) + mouseX;
                                else targetRotY = 0.5 + mouseX;
                                
                                targetRotX = 0.3 + mouseY;
                            });

                            container.addEventListener('mouseleave', () => {
                                targetRotX = 0.3; 
                                if (shape === 'phone') targetRotY = Math.PI;
                                else if (shape === 'truck') targetRotY = -Math.PI * 0.25;
                                else targetRotY = 0.5;
                            });

                            function animateGLB() {
                                requestAnimationFrame(animateGLB);
                                if (object3D) {
                                    rotX += (targetRotX - rotX) * 0.05;
                                    rotY += (targetRotY - rotY) * 0.05;
                                    object3D.rotation.x = rotX;
                                    object3D.rotation.y = rotY;
                                    const s = 0.98 + Math.sin(Date.now() * 0.0008) * 0.02;
                                    object3D.scale.set(s, s, s);
                                }
                                renderer.render(scene, camera);
                            }
                            animateGLB();

                        }

                        // Helper for fallbacks to avoid code duplication
                        function loadFallback(shape, scene, callback) {
                            let pointsData;
                            switch(shape) {
                                case 'phone': pointsData = generatePhonePoints(); break;
                                case 'building': pointsData = generateBuildingPoints(); break;
                                case 'truck': pointsData = generateTruckPoints(); break;
                                default: pointsData = generatePhonePoints();
                            }
                            const geo = new THREE.BufferGeometry();
                            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pointsData.flat()), 3));
                            // Create refined particle texture with soft, glowing edges
                            const canvasCircle = document.createElement('canvas');
                            canvasCircle.width = 128; canvasCircle.height = 128;
                            const ctxC = canvasCircle.getContext('2d');
                            // Radial gradient for softer, more polished particles with glow
                            const grad = ctxC.createRadialGradient(64, 64, 0, 64, 64, 64);
                            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
                            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                            ctxC.fillStyle = grad;
                            ctxC.beginPath(); ctxC.arc(64, 64, 64, 0, Math.PI * 2);
                            ctxC.fill();
                            const tex = new THREE.CanvasTexture(canvasCircle);
                            tex.minFilter = THREE.LinearFilter;
                            tex.magFilter = THREE.LinearFilter;
                            tex.generateMipmaps = false;
                            tex.premultiplyAlpha = true;
                            tex.needsUpdate = true;
                            // Enhanced material with additive blending for ultra-bright look
                            const mat = new THREE.PointsMaterial({ 
                                size: 2.5, 
                                map: tex, 
                                color: 0x44ffaa, 
                                transparent: true, 
                                opacity: 1.0, 
                                depthWrite: false, 
                                depthTest: false, 
                                blending: THREE.AdditiveBlending, 
                                sizeAttenuation: true 
                            });
                            const pts = new THREE.Points(geo, mat);
                            scene.add(pts);
                            callback(pts);
                        }

                        window.addEventListener('resize', () => {
                            const nw = container.clientWidth, nh = container.clientHeight;
                            if (nw > 0 && nh > 0) {
                                renderer.setSize(nw, nh);
                                camera.aspect = nw / nh;
                                camera.updateProjectionMatrix();
                            }
                        });
                    } catch (e) { console.error(e); }
                };

                const ro = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            initViz(width, height);
                            ro.disconnect();
                        }
                    }
                });
                ro.observe(container);
            });
        })();

        // Three.js Background - Positioned & Rounded
        function initBg() {
            const container = document.getElementById('bg-canvas');
            if(!container) return;
            
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x030303, 0.03);

            const getDims = () => ({
                w: container.clientWidth,
                h: container.clientHeight
            });
            let dims = getDims();

            const camera = new THREE.PerspectiveCamera(75, dims.w / dims.h, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
            renderer.setSize(dims.w, dims.h);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);

            // Geometry - Sharp Architectural Cubes (Edges only)
            const geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const edgesGeometry = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.85
            });
            
            const cubes = [];
            const group = new THREE.Group();
            
            // Cluster Logic: Rubik-style Grid (Organized but fractured)
            const gridSize = 4;
            const spacing = 1.4;
            for(let x=0; x<gridSize; x++) {
                for(let y=0; y<gridSize; y++) {
                    for(let z=0; z<gridSize; z++) {
                        // Skip some to create "voids" in the rubik structure
                        if(Math.random() < 0.4) continue;

                        const cube = new THREE.LineSegments(edgesGeometry, material.clone());
                        
                        // Base Grid Position
                        let px = (x - (gridSize-1)/2) * spacing;
                        let py = (y - (gridSize-1)/2) * spacing;
                        let pz = (z - (gridSize-1)/2) * spacing;

                        // "Fractured" logic: Spread some cubes away from the center
                        const distanceFactor = Math.random();
                        if(distanceFactor > 0.7) {
                            // Small outward nudge to keep them close but distinct
                            const dir = new THREE.Vector3(px, py, pz).normalize();
                            if(dir.length() === 0) dir.set(1, 1, 1).normalize();
                            
                            const pushDistance = 0.6 + Math.random() * 0.8; 
                            px += dir.x * pushDistance;
                            py += dir.y * pushDistance;
                            pz += dir.z * pushDistance;
                        }

                        cube.position.set(px, py, pz);
                        cube.rotation.set(0, 0, 0); // All cubes share the same orientation
                        group.add(cube);
                        cubes.push(cube);
                    }
                }
            }
            
            // Reposition beside text
            const updateGroupPos = () => {
                group.position.x = dims.w > 768 ? 4 : 0;
                group.position.y = dims.w > 768 ? 0 : -2;
            };
            updateGroupPos();
            scene.add(group);

            camera.position.z = 12;

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let selectedObject = null;
            let isDragging = false;
            const dragPlane = new THREE.Plane();
            const planeNormal = new THREE.Vector3(0, 0, 1);
            const intersection = new THREE.Vector3();
            let offset = new THREE.Vector3();

            const updateMouse = (e) => {
                const rect = container.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / dims.w) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / dims.h) * 2 + 1;
            };

            container.addEventListener('mousemove', (e) => {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);

                if (isDragging && selectedObject) {
                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        // Move in group space
                        const localIntersection = group.worldToLocal(intersection.clone().sub(offset));
                        selectedObject.position.copy(localIntersection);
                    }
                    return;
                }

                const intersects = raycaster.intersectObjects(cubes);
                document.body.style.cursor = intersects.length > 0 ? 'grab' : 'crosshair';
            });

            container.addEventListener('mousedown', (e) => {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubes);

                if (intersects.length > 0) {
                    isDragging = true;
                    selectedObject = intersects[0].object;
                    
                    planeNormal.copy(camera.position).normalize();
                    const worldPos = new THREE.Vector3();
                    selectedObject.getWorldPosition(worldPos);
                    dragPlane.setFromNormalAndCoplanarPoint(planeNormal, worldPos);
                    
                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        offset.copy(intersection).sub(worldPos);
                    }
                    
                    document.body.style.cursor = 'grabbing';
                    selectedObject.material.color.setHex(0xffffff); // Highlight white
                }
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                if(selectedObject) {
                    selectedObject.material.color.setHex(0x00ff88); // Reset to green
                    selectedObject = null;
                }
            });

            window.addEventListener('resize', () => {
                dims = getDims();
                camera.aspect = dims.w / dims.h;
                camera.updateProjectionMatrix();
                renderer.setSize(dims.w, dims.h);
                updateGroupPos();
            });

            function animate() {
                requestAnimationFrame(animate);
                // ALWAYS rotate to maintain momentum (slower)
                group.rotation.y += 0.001;
                group.rotation.z += 0.0003;
                renderer.render(scene, camera);
            }
            animate();
        }
        
        initBg();
        
        // --- BG Particles & Parallax ---
        (function initParticles(){
            const container = document.getElementById('bg-canvas');
            if(!container) return;

            // canvas for particles
            const canvas = document.createElement('canvas');
            canvas.id = 'bg-particles';
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            let DPR = Math.max(1, window.devicePixelRatio || 1);
            let W = 0, H = 0;
            function resize() {
                W = canvas.width = Math.max(300, container.clientWidth) * DPR;
                H = canvas.height = Math.max(300, container.clientHeight) * DPR;
                canvas.style.width = (W / DPR) + 'px';
                canvas.style.height = (H / DPR) + 'px';
            }
            window.addEventListener('resize', resize);
            resize();

            const PCOUNT = 80;
            const particles = [];
            for(let i=0;i<PCOUNT;i++) particles.push({ x: Math.random()*W, y: Math.random()*H, r: (Math.random()*1.6+0.6)*DPR, vx: (Math.random()-0.5)*0.25, vy: (Math.random()-0.5)*0.25, a: (Math.random()*0.6+0.15) });

            let mx = 0, my = 0, tx = 0, ty = 0;
            container.addEventListener('mousemove', e => {
                const rect = container.getBoundingClientRect();
                mx = ((e.clientX - rect.left) / rect.width - 0.5);
                my = ((e.clientY - rect.top) / rect.height - 0.5);
            });
            window.addEventListener('scroll', () => {
                ty = window.scrollY * 0.01;
            });

            function draw() {
                ctx.clearRect(0,0,W,H);
                tx += (mx*30 - tx) * 0.06; // smooth
                ty += (ty - ty) * 0.02; // no-op but reserved for future

                for(let p of particles){
                    p.x += p.vx; p.y += p.vy;
                    if(p.x < -50) p.x = W + 50;
                    if(p.x > W + 50) p.x = -50;
                    if(p.y < -50) p.y = H + 50;
                    if(p.y > H + 50) p.y = -50;

                    ctx.beginPath();
                    ctx.fillStyle = `rgba(0,255,136,${p.a})`;
                    ctx.arc(p.x + mx*12*DPR, p.y + my*12*DPR, p.r, 0, Math.PI*2);
                    ctx.fill();
                }
                requestAnimationFrame(draw);
            }
            draw();

            // parallax transform for bg-canvas
            let px = 0, py = 0;
            function updateParallax(){
                px += (mx * 8 - px) * 0.06;
                py += (my * 8 - py) * 0.06;
                container.style.transform = `translate3d(${px}px, ${py}px, 0)`;
                requestAnimationFrame(updateParallax);
            }
            updateParallax();
        })();

        // Reveal, arrow micro-interactions, tilt & scroll parallax
        (function initRevealAndTilt(){
            // Intersection Observer for reveal animations
            const io = new IntersectionObserver((entries) => {
                entries.forEach((entry, idx) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                        const delay = (entry.target.datasetRevealIndex || 0) * 60;
                        entry.target.style.transitionDelay = (delay) + 'ms';
                        io.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.12 });

            const workCards = Array.from(document.querySelectorAll('.work-card, .section-heading'));
            workCards.forEach((el, i) => {
                el.datasetRevealIndex = i;
                el.classList.add('reveal');
                io.observe(el);
            });

        })();

    </script>

    <!-- Background Animation Script -->
    <script type="module">
        import * as THREE from 'three';

        // Updated ID to avoid conflict with Hero Cubes
        const canvas = document.getElementById('bg-wave-canvas');
        const parent = canvas.parentElement;
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        
        function updateSize() {
            const w = parent.clientWidth;
            const h = parent.clientHeight;
            renderer.setSize(w, h);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            if (camera) {
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            }
        }

        const scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x050505, 0.0015); 

        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.z = 50; 
        camera.position.y = 15;
        camera.rotation.x = -0.3;

        updateSize();

        const geometry = new THREE.BufferGeometry();
        // Waves
        const count = 2500;
        const positions = new Float32Array(count * 3);
        const originalPositions = new Float32Array(count * 3);
        
        // Spread particles in a grid/plane
        let i = 0;
        const size2 = 180;
        const gap = 3.5;
        const columns = Math.sqrt(count);
        
        for (let x = 0; x < columns; x++) {
            for (let z = 0; z < columns; z++) {
                // Centered grid
                const px = (x * gap) - (columns * gap) / 2;
                const pz = (z * gap) - (columns * gap) / 2;
                
                positions[i] = px;
                positions[i+1] = 0; // Y
                positions[i+2] = pz;
                
                originalPositions[i] = px;
                originalPositions[i+1] = 0;
                originalPositions[i+2] = pz;

                i += 3;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            size: 0.15,
            color: 0x00ff88, // Accent color
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            const time = clock.getElapsedTime() * 0.5;

            // Wave effect
            const pos = geometry.attributes.position.array;
            for(let j=0; j < count; j++) {
                const x = originalPositions[j*3];
                const z = originalPositions[j*3 + 2];
                // Sine wave based on x, z and time
                pos[j*3 + 1] = (Math.sin(x * 0.05 + time) * 3) + (Math.cos(z * 0.05 + time) * 3); 
            }
            geometry.attributes.position.needsUpdate = true;

            // Gentle rotation
            particles.rotation.y = time * 0.02;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- Icosahedron Button Logic ---
        const icoButtons = document.querySelectorAll('.ico-btn');
        const icoScenes = [];

        icoButtons.forEach(btn => {
            const canvas = btn.querySelector('.ico-canvas');
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            renderer.setSize(100, 100);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            camera.position.z = 6; // Moved back for more room

            // Wireframe Icosahedron
            const geometry = new THREE.IcosahedronGeometry(1.5, 1); // Reduced size
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.4 
            });
            const mesh = new THREE.LineSegments(edges, material);
            scene.add(mesh);

            // Inner solid but very faint icosahedron for volume
            const innerGeo = new THREE.IcosahedronGeometry(1.45, 0); // Reduced size
            const innerMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.05
            });
            const innerMesh = new THREE.Mesh(innerGeo, innerMat);
            scene.add(innerMesh);

            icoScenes.push({ btn, scene, camera, renderer, mesh, innerMesh });
        });

        function animateIcos() {
            icoScenes.forEach(item => {
                const isHovered = item.btn.matches(':hover');
                const speed = isHovered ? 0.02 : 0.005;
                
                item.mesh.rotation.y += speed;
                item.mesh.rotation.z += speed * 0.5;
                item.innerMesh.rotation.y += speed;
                item.innerMesh.rotation.z += speed * 0.5;

                // Scale effect on hover
                const targetScale = isHovered ? 1.2 : 1.0;
                item.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                item.innerMesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                
                // Opacity effect
                item.mesh.material.opacity = THREE.MathUtils.lerp(item.mesh.material.opacity, isHovered ? 0.8 : 0.4, 0.1);

                item.renderer.render(item.scene, item.camera);
            });
            requestAnimationFrame(animateIcos);
        }
        animateIcos();

        // Resize
        window.addEventListener('resize', updateSize);

        // --- Logo Geometry Animation ---
        const logoCanvas = document.querySelector('.logo-canvas');
        if (logoCanvas) {
            const logoRenderer = new THREE.WebGLRenderer({ 
                canvas: logoCanvas, 
                alpha: true, // Transparent bg to blend with noise
                antialias: true 
            });
            logoRenderer.setSize(36, 36);
            logoRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const logoScene = new THREE.Scene();
            const logoCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            logoCamera.position.z = 4;

            // Soft lighting for subtle speculars
            const la = new THREE.AmbientLight(0xffffff, 0.6);
            logoScene.add(la);
            const lp = new THREE.PointLight(0x00ff88, 0.8, 10);
            lp.position.set(2, 2, 2);
            logoScene.add(lp);

            // Simple cube logo (restored)
            const logoGeometry = new THREE.BoxGeometry(1, 1, 1);
            const logoEdges = new THREE.EdgesGeometry(logoGeometry);
            const logoMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0.8 // Slightly more transparent by default
            });
            const logoShape = new THREE.LineSegments(logoEdges, logoMaterial);
            logoScene.add(logoShape);

            // Inner faint cube for volume
            const innerLogoGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const innerLogoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0.05, 
                metalness: 0.2, 
                roughness: 0.6 
            });
            const innerLogoCube = new THREE.Mesh(innerLogoGeometry, innerLogoMaterial);
            logoScene.add(innerLogoCube);

            // Scale down logo to fit beside content (increased slightly)
            const LOGO_SCALE = 0.72;
            logoShape.scale.set(LOGO_SCALE, LOGO_SCALE, LOGO_SCALE);
            innerLogoCube.scale.set(LOGO_SCALE, LOGO_SCALE, LOGO_SCALE);

            let logoHover = false;
            let rotationSpeed = 1;
            let currentRotationX = 0;
            let currentRotationY = 0;
            
            const siteLogoEl = document.querySelector('.site-logo');
            if (siteLogoEl) {
                siteLogoEl.addEventListener('mouseenter', () => { logoHover = true; });
                siteLogoEl.addEventListener('mouseleave', () => { logoHover = false; });
            }

            function animateLogo() {
                // Toned down rotation speed multiplier (from 5.0 to 2.5) for a more elegant feel
                const targetSpeed = logoHover ? 2.5 : 1.0;
                rotationSpeed += (targetSpeed - rotationSpeed) * 0.05; // Slower lerp for more fluid motion

                currentRotationX += 0.008 * rotationSpeed;
                currentRotationY += 0.012 * rotationSpeed;

                logoShape.rotation.x = currentRotationX;
                logoShape.rotation.y = currentRotationY;
                innerLogoCube.rotation.x = currentRotationX;
                innerLogoCube.rotation.y = currentRotationY;

                // Subtle opacity shift on hover handled in JS for sync
                logoMaterial.opacity = THREE.MathUtils.lerp(logoMaterial.opacity, logoHover ? 1.0 : 0.8, 0.1);

                logoRenderer.render(logoScene, logoCamera);
                requestAnimationFrame(animateLogo);
            }
            animateLogo();

            // Align site logo with the page grid (keeps it visually in the left content column)
            const grid = document.querySelector('.grid-container');

            // Ensure the logo is not nested inside the HUD (or any transformed ancestor).
            // If it is, move it to document.body so it behaves relative to the document (page) instead of the viewport.
            function separateLogoIfNeeded() {
                if (!siteLogoEl) return;
                const offendingAncestor = siteLogoEl.closest('.hud-nav, [style*="transform"], [style*="backdrop-filter"], [style*="will-change"]');
                if (offendingAncestor && offendingAncestor !== document.body) {

                    document.body.appendChild(siteLogoEl);
                    // Use absolute positioning so the logo sits at a fixed document coordinate (scroll moves it along with page)
                    siteLogoEl.style.position = 'absolute';
                    siteLogoEl.style.zIndex = 2000;
                }
            }

            // Locking: once the initial position is computed, keep the logo at the same document coordinate
            // (so it stays at the beginning of the page and scroll will move it with the content)
            let logoLocked = false;
            function updateLogoAlignment() {
                if (!siteLogoEl) return;
                if (logoLocked) return; // already set

                // Ensure logo is separated first
                separateLogoIfNeeded();

                // Compute horizontal (content left) alignment (document coordinates)
                let leftViewport = 40;
                if (grid) {
                    const rect = grid.getBoundingClientRect();
                    leftViewport = Math.max(12, Math.round(rect.left + 12));
                }
                const leftDoc = leftViewport + window.scrollX;
                siteLogoEl.style.left = leftDoc + 'px';

                // Compute document-top lock: capture current document-relative top and set absolute
                const logoRect = siteLogoEl.getBoundingClientRect();
                const docTop = Math.round(logoRect.top + window.scrollY);

                // Set absolute document positioning and remove transitions
                siteLogoEl.style.transition = 'none';
                siteLogoEl.style.position = 'absolute';
                siteLogoEl.style.top = docTop + 'px';

                // Lock so future nav changes won't move the logo
                logoLocked = true;

            }
            updateLogoAlignment();

            // On resize we may need to update the *left* offset so the logo stays aligned with the content column
            window.addEventListener('resize', () => {
                if (!siteLogoEl) return;
                const rect = grid ? grid.getBoundingClientRect() : null;
                const leftViewport = rect ? Math.max(12, Math.round(rect.left + 12)) : 40;
                const leftDoc = leftViewport + window.scrollX;
                siteLogoEl.style.left = leftDoc + 'px';
            });

            // Logo stays fixed at its document start position; scrolling moves it with the page (no jitter)

            // site-logo debug removed — observer/logging was noisy in console.

            // Entrance effects for links
            const navLinks = Array.from(document.querySelectorAll('.hud-link'));

            navLinks.forEach((link, i) => {
                // entrance animation delay
                setTimeout(() => {
                    link.style.opacity = '1';
                }, 150 * i);
            });

            // Section Observer for Active Navigation
            const observerOptions = {
                threshold: 0.3
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.getAttribute('id');
                        navLinks.forEach(link => {
                            link.classList.toggle('active', 
                                (link.getAttribute('href') === '#' + id) || 
                                (link.getAttribute('href') === '#' && id === 'about')
                            );
                        });
                    }
                });
            }, observerOptions);

            document.querySelectorAll('section[id]').forEach(section => {
                observer.observe(section);
            });
        }
    </script>

    <script>
        (function(){
            const VAR_KEY = 'hero_ab_variant';
            const variants = [
                {
                    id: 'ux-ai-strategy',
                    badge: '',
                    title: 'Solving for complex product problems through systemic UX and AI intelligence.',
                    sub: 'Senior UX Designer with 8 years of experience, using AI-driven workflows to eliminate operational noise and focus on user strategy.',
                    micro: 'Currently helping products scale through high-performance design.',
                    cta: 'SEE WORK ↓'
                },
                {
                    id: 'impact-ux',
                    badge: '',
                    title: 'Strategic Lead Designer driving real impact through AI-powered execution.',
                    sub: 'Scaling legacy systems and complex flows by blending 8+ years of UX expertise with autonomous design methodologies.',
                    micro: 'Specialized in Fintech, Telecom, and high-scale B2B.',
                    cta: 'VIEW CASES ↓'
                },
                {
                    id: 'systemic-design',
                    badge: '',
                    title: 'I design systemic solutions for products that need to grow fast.',
                    sub: 'Removing design friction using AI to focus 100% of the energy on solving the core business problems that actually matter.',
                    micro: 'Senior UX & Product Strategy.',
                    cta: 'SEE IMPACT ↓'
                }
            ];

            function pickVariant() {
                const url = new URL(window.location.href);
                const q = url.searchParams.get('ab');
                if (q) {
                    const v = variants.find(x => x.id === q);
                    if (v) {
                        localStorage.setItem(VAR_KEY, v.id);
                        console.log('A/B preview override to variant:', v.id);
                        return v;
                    }
                }
                const stored = localStorage.getItem(VAR_KEY);
                if (stored) {
                    const s = variants.find(x => x.id === stored);
                    if (s) return s;
                }
                // Random assign with equal weights
                const choice = variants[Math.floor(Math.random() * variants.length)];
                localStorage.setItem(VAR_KEY, choice.id);
                console.log('A/B assigned variant:', choice.id);
                return choice;
            }

            function renderVariant(v) {
                const b = document.getElementById('hero-badge');
                const t = document.getElementById('hero-title');
                const s = document.getElementById('hero-sub');
                const m = document.getElementById('hero-micro');
                const c = document.getElementById('hero-cta');
                if (!t || !s || !m || !c) return;
                // badge is optional; hide it when not provided
                if (b) {
                    if (v.badge) {
                        b.textContent = v.badge;
                        b.style.display = '';
                        b.removeAttribute('aria-hidden');
                    } else {
                        b.textContent = '';
                        b.style.display = 'none';
                        b.setAttribute('aria-hidden', 'true');
                    }
                }
                document.getElementById('hero-copy').setAttribute('data-ab-variant', v.id);
            }

            function animateVariantTransition(v) {
                const container = document.getElementById('hero-copy');
                if (!container) { renderVariant(v); return Promise.resolve(); }
                if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    renderVariant(v);
                    return Promise.resolve();
                }
                return new Promise(resolve => {
                    container.classList.add('hero-fade-out');
                    // allow CSS to animate
                    setTimeout(() => {
                        renderVariant(v);
                        // trigger reflow and fade in
                        void container.offsetWidth;
                        container.classList.remove('hero-fade-out');
                        container.classList.add('hero-fade-in');
                        setTimeout(() => {
                            container.classList.remove('hero-fade-in');
                            resolve();
                        }, 420);
                    }, 260);
                });
            }

            // Intro cycle removed: demo disabled. Variant cycling is manual via the 'V' hotkey.

            // Render on DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => { renderVariant(pickVariant());
                    // One-time decoding demo on first visit

                });
            } else {
                renderVariant(pickVariant());

            }

            // Keyboard quick-swap (dev): press V to cycle only the *titles* with a letter animation
            (function devHotKeysAndTitleCycle(){
                // Dev helper removed in production build (kept minimal stub)

                // Helper: split text into word-wrapped spans with inner letter spans (prevents mid-word breaks)
                function toSpannedHTML(text) {
                    const inner = text.split(/(\s+)/).map(part => {
                        if (/^\s+$/.test(part)) return '<span class="title-space">&nbsp;</span>';
                        const letters = Array.from(part).map(ch => `<span class="title-letter">${ch}</span>`).join('');
                        return `<span class="title-word">${letters}</span>`;
                    }).join('');
                    return `<span class="title-clip">${inner}</span>`;
                }

                // Original flip/glow animation renamed
                function animateTitleFlipTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    return new Promise(resolve => {
                        // Ensure current title is spanned
                        if (!el.querySelector('.title-letter')) {
                            el.innerHTML = toSpannedHTML(el.textContent || '');
                        }
                        const currentLetters = Array.from(el.querySelectorAll('.title-letter'));
                        // Exit animation staggered by letter
                        currentLetters.forEach((span, i) => {
                            setTimeout(() => span.classList.add('letter-exit'), i * 26);
                        });

                        // After exit, put new words/letters and animate them in with glow and word-group staggering
                        const exitDuration = currentLetters.length * 26 + 240;
                        setTimeout(() => {
                            el.innerHTML = toSpannedHTML(nextTitle);
                            const newLetters = Array.from(el.querySelectorAll('.title-letter'));
                            // Start in 'enter' state
                            newLetters.forEach(span => span.classList.add('letter-enter'));

                            if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                                // If reduced motion, just show text
                                newLetters.forEach(span => span.classList.remove('letter-enter'));
                                setTimeout(() => resolve(), 0);
                                return;
                            }

                            // stagger remove of enter class and add a brief glow as letters appear
                            let delay = 20;
                            Array.from(el.querySelectorAll('.title-word')).forEach((word) => {
                                const letters = Array.from(word.querySelectorAll('.title-letter'));
                                letters.forEach((span, j) => {
                                    setTimeout(() => {
                                        span.classList.remove('letter-enter');
                                        // quick glow on appearance
                                        span.classList.add('glow');
                                        setTimeout(() => span.classList.remove('glow'), 420);
                                    }, delay + j * 22);
                                });
                                delay += letters.length * 22 + 48;
                            });
                            const enterDuration = delay + 240;
                            setTimeout(() => resolve(), enterDuration);
                        }, exitDuration);
                    });
                }

                // Wrapper that dispatches to the selected effect
                function animateTitleTo(nextTitle) {
                    const effect = window._heroTitleEffect || localStorage.getItem('title_effect') || 'decode';
                    switch(effect) {
                        case 'glitch': return animateTitleGlitchTo(nextTitle);
                        case 'slice': return animateTitleSliceTo(nextTitle);
                        case 'particle': return animateTitleParticleTo(nextTitle);
                        case 'crt': return animateTitleCRTTo(nextTitle);
                        case 'decode': return animateTitleDecodeTo(nextTitle);
                        case 'plain':
                            document.getElementById('hero-title').innerHTML = nextTitle.replace('\n','<br>');
                            return Promise.resolve();
                        case 'flip':
                        default: return animateTitleFlipTo(nextTitle);
                    }
                }

                // ---- Glitch effect (simple layer-based) ----
                function animateTitleGlitchTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    const container = el.parentElement;
                    // create glitch layers
                    const glitchWrap = document.createElement('span');
                    glitchWrap.className = 'title-glitch';
                    const base = el.cloneNode(true);
                    const r = base.cloneNode(true);
                    r.className = 'glitch-layer layer-r';
                    const g = base.cloneNode(true);
                    g.className = 'glitch-layer layer-g';
                    glitchWrap.appendChild(base);
                    glitchWrap.appendChild(r);
                    glitchWrap.appendChild(g);
                    // replace title with wrap
                    container.replaceChild(glitchWrap, el);

                    return new Promise(resolve => {
                        // animate glitch then swap text
                        glitchWrap.classList.add('glitch-animate');
                        setTimeout(() => {
                            base.innerHTML = nextTitle.replace('\n','<br>');
                            r.innerHTML = base.innerHTML;
                            g.innerHTML = base.innerHTML;
                            // remove animation
                            glitchWrap.classList.remove('glitch-animate');
                            // unwrap: put base back into container
                            container.replaceChild(base, glitchWrap);
                            resolve();
                        }, 420);
                    });
                }

                // ---- Decoding / hacking style reveal (sequential letters) ----
                async function animateTitleDecodeTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    // A cleaner terminal-style charset
                    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<>[]/\\+=-_';

                    // Build spanned HTML (preserve words)
                    const words = nextTitle.split(/(\s+)/).map(part => {
                        if (/^\s+$/.test(part)) return '<span class="title-space">&nbsp;</span>';
                        const letters = Array.from(part).map(ch => `<span class="title-letter decoding">${charset.charAt(Math.floor(Math.random()*charset.length))}</span>`).join('');
                        return `<span class="title-word">${letters}</span>`;
                    }).join('');

                    el.innerHTML = `<span class="title-clip">${words}</span>`;

                    const letterSpans = Array.from(el.querySelectorAll('.title-letter'));
                    // FIX: Filter out whitespace from finals so they map correctly to .title-letter spans
                    const finals = Array.from(nextTitle).filter(ch => !/\s/.test(ch));

                    // Map final characters to letter spans
                    let fIdx = 0;
                    const targets = letterSpans.map(() => finals[fIdx++] || '');

                    // IMPORTANT: measure and lock each span width to the final character width so
                    // random decoding characters cannot change layout or cause word breaks.
                    await (async function lockLetterWidths(){
                        // Ensure hero webfont is loaded to avoid measuring with a fallback font which
                        // can yield different metrics and cause spacing issues on decode.
                        try {
                            const fontName = 'JetBrains Mono';
                            if (document.fonts && !document.fonts.check(`1em "${fontName}"`)) {
                                console.log('TITLE-DECODE-FONT: waiting for', fontName);
                                await Promise.race([
                                    document.fonts.load(`1em "${fontName}"`),
                                    new Promise(res => setTimeout(res, 300))
                                ]);
                                console.log('TITLE-DECODE-FONT: ready?', document.fonts.check(`1em "${fontName}"`));
                            } else {
                                console.log('TITLE-DECODE-FONT: already available');
                            }
                        } catch(e) { console.warn('TITLE-DECODE-FONT: check failed', e); }

                        // create a hidden measurement span matching the hero font
                        const style = getComputedStyle(el);
                        const font = style.font || 'bold 6vw JetBrains Mono, monospace';
                        const lineH = style.lineHeight || '1';
                        const letterSpacing = style.letterSpacing || 'normal';
                        
                        const meas = document.createElement('span');
                        meas.style.position = 'absolute'; 
                        meas.style.visibility = 'hidden'; 
                        meas.style.whiteSpace = 'pre'; 
                        meas.style.font = font; 
                        meas.style.lineHeight = lineH;
                        // Keep letter-spacing 'normal' during measurement to get the raw glyph width.
                        // The parent's letter-spacing will then pull these inline-blocks together naturally.
                        meas.style.letterSpacing = 'normal'; 
                        document.body.appendChild(meas);

                        // Ensure words don't break inside and preserve layout
                        Array.from(el.querySelectorAll('.title-word')).forEach(w => {
                            w.style.display = 'inline-block';
                            w.style.whiteSpace = 'nowrap';
                            w.style.verticalAlign = 'middle';
                        });

                        letterSpans.forEach((span, idx) => {
                            const ch = targets[idx] || ' ';
                            meas.textContent = ch;
                            const rect = meas.getBoundingClientRect();
                            const w = rect.width;
                            
                            // Use exact measured width and inline-block to preserve natural spacing/kerning.
                            // We avoid padding and min-width padding which were disrupting the compressed look.
                            span.style.display = 'inline-block';
                            span.style.textAlign = 'center';
                            span.style.width = w + 'px';
                            span.style.lineHeight = lineH; 
                            span.style.overflow = 'hidden'; 
                            span.style.verticalAlign = 'middle';
                            
                            // record locked width for runtime diagnostics
                            try { span._lockedWidth = w; } catch (e) { }
                        });
                        document.body.removeChild(meas);
                        // diagnostic snapshot of locked widths
                        try {
                            const widths = letterSpans.slice(0,10).map(s => parseFloat(s.style.width) || s.getBoundingClientRect().width);
                            const avg = Math.round(widths.reduce((a,b)=>a+b,0)/(widths.length||1));
                            console.log('TITLE-DECODE-LOCKED', { count: letterSpans.length, sample: widths, avg });
                        } catch(e) {}
                    })();

                    // Staggered overlapping decode with a "walking" cursor
                    return new Promise(resolve => {
                        let settled = 0;
                        const stagger = 25; 

                        letterSpans.forEach((span, i) => {
                            const startDelay = i * stagger;
                            setTimeout(() => {
                                // The "walking" cursor: remove from all, add to this one.
                                // Since they start in order, this keeps it at the "head" of the wave.
                                letterSpans.forEach(s => s.classList.remove('has-cursor'));
                                span.classList.add('active', 'has-cursor');
                                
                                // Increase steps so the "decode" scramble is actually visible
                                let steps = 6 + Math.floor(Math.random() * 6);
                                function tick() {
                                    if (steps-- <= 0) {
                                        span.classList.remove('decoding', 'active', 'has-cursor');
                                        span.classList.add('settled');
                                        span.textContent = targets[i] || '';
                                        settled++;
                                        if (settled === letterSpans.length) resolve();
                                        return;
                                    }

                                    span.textContent = charset.charAt(Math.floor(Math.random() * charset.length));
                                    setTimeout(tick, 20);
                                }
                                tick();
                            }, startDelay);
                        });

                        // safety timeout
                        setTimeout(() => { if (letterSpans.some(s=>s.classList.contains('decoding'))) resolve(); }, 4000);
                    });
                }

                // ---- Slice effect (word-level masked slide) ----
                function animateTitleSliceTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }
                    return new Promise(resolve => {
                        // Transform each .title-word out and slide in new ones
                        if (!el.querySelector('.title-word')) el.innerHTML = toSpannedHTML(el.textContent || '');
                        const words = Array.from(el.querySelectorAll('.title-word'));
                        words.forEach((w, i) => {
                            w.style.transition = 'transform 380ms cubic-bezier(.2,.9,.3,1), opacity 300ms';
                            w.style.transform = 'translateY(-20px) rotateX(-12deg)';
                            w.style.opacity = '0';
                        });
                        const exitDur = 260;
                        setTimeout(() => {
                            el.innerHTML = toSpannedHTML(nextTitle);
                            const newWords = Array.from(el.querySelectorAll('.title-word'));
                            newWords.forEach((w, i) => {
                                w.style.transform = 'translateY(18px) rotateX(30deg)';
                                w.style.opacity = '0';
                                setTimeout(() => {
                                    w.style.transition = 'transform 420ms cubic-bezier(.2,.9,.3,1), opacity 360ms';
                                    w.style.transform = 'translateY(0) rotateX(0)';
                                    w.style.opacity = '1';
                                }, i * 72);
                            });
                            setTimeout(() => resolve(), newWords.length * 72 + 440);
                        }, exitDur);
                    });
                }

                // ---- Particle morph (canvas-based) ----
                function animateTitleParticleTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    // basic particle morph implementation
                    const rect = el.getBoundingClientRect();
                    const canvas = document.createElement('canvas');
                    canvas.className = 'particle-layer';
                    canvas.width = Math.min(1024, Math.ceil(rect.width));
                    canvas.height = Math.min(256, Math.ceil(rect.height));
                    canvas.style.left = rect.left + 'px';
                    canvas.style.top = (rect.top + window.scrollY) + 'px';
                    document.body.appendChild(canvas);
                    const ctx = canvas.getContext('2d');

                    function sampleTextPoints(text) {
                        const tmp = document.createElement('canvas');
                        tmp.width = canvas.width; tmp.height = canvas.height;
                        const tctx = tmp.getContext('2d');
                        tctx.fillStyle = '#fff';
                        const fs = Math.round(canvas.height * 0.72);
                        tctx.font = `${fs}px JetBrains Mono, monospace`;
                        tctx.textAlign = 'left';
                        tctx.textBaseline = 'middle';
                        tctx.clearRect(0,0,tmp.width,tmp.height);
                        tctx.fillText(text, 0, tmp.height/2);
                        const pts = [];
                        const img = tctx.getImageData(0,0,tmp.width,tmp.height);
                        for (let y = 0; y < tmp.height; y+=6) {
                            for (let x = 0; x < tmp.width; x+=6) {
                                const idx = (y*tmp.width + x) * 4 + 3;
                                if (img.data[idx] > 128) pts.push({x, y});
                            }
                        }
                        return pts;
                    }

                    const srcPoints = sampleTextPoints(el.textContent || '');
                    const dstPoints = sampleTextPoints(nextTitle);
                    const N = Math.min(srcPoints.length, dstPoints.length, 1200);
                    const particles = [];
                    for (let i = 0; i < N; i++) {
                        const s = srcPoints[i % srcPoints.length];
                        const d = dstPoints[i % dstPoints.length];
                        particles.push({ x: s.x, y: s.y, tx: d.x, ty: d.y, vx: 0, vy: 0, life: 0 });
                    }

                    // hide title while animating
                    const originalHTML = el.innerHTML;
                    el.style.visibility = 'hidden';

                    const start = performance.now();
                    const dur = 920;
                    function easeOutC(t){ return 1 - Math.pow(1-t, 3); }
                    function tick(now) {
                        const t = Math.min(1, (now - start) / dur);
                        ctx.clearRect(0,0,canvas.width,canvas.height);
                        for (let i = 0; i < particles.length; i++) {
                            const p = particles[i];
                            const ix = p.x + (p.tx - p.x) * easeOutC(t) + (Math.sin((i*7)+t*10)*6*(1-t));
                            const iy = p.y + (p.ty - p.y) * easeOutC(t) + (Math.cos((i*11)+t*8)*4*(1-t));
                            ctx.fillStyle = 'rgba(0,255,136,0.9)';
                            ctx.beginPath(); ctx.arc(ix, iy, 1.5, 0, Math.PI*2); ctx.fill();
                        }
                        if (t < 1) requestAnimationFrame(tick); else {
                            // done
                            document.body.removeChild(canvas);
                            el.innerHTML = nextTitle.replace('\n','<br>');
                            el.style.visibility = '';
                        }
                    }
                    return new Promise(resolve => {
                        requestAnimationFrame(now => {
                            tick(now);
                            setTimeout(() => resolve(), dur + 80);
                        });
                    });
                }

                // ---- CRT type effect ----
                function animateTitleCRTTo(nextTitle) {
                    const el = document.getElementById('hero-title');
                    if (!el) return Promise.resolve();
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        el.innerHTML = nextTitle.replace('\n','<br>');
                        return Promise.resolve();
                    }

                    return new Promise(resolve => {
                        el.classList.add('title-crt');
                        const chars = Array.from(nextTitle);
                        el.textContent = '';
                        let i=0;
                        function step(){
                            if (i >= chars.length) { el.classList.remove('title-crt'); resolve(); return; }
                            el.textContent += chars[i];
                            // small flicker effect
                            if (Math.random() < 0.12) el.style.opacity = '0.8'; else el.style.opacity = '1';
                            i++;
                            setTimeout(step, 40 + Math.random()*30);
                        }
                        step();
                    });
                }

                // Production defaults: use decode and disable dev controls
                window._heroTitleEffect = 'decode';

                // --- Auto cycle (re-enabled) ---
                const TITLE_KEY = 'hero_title_idx';
                function getStoredIdx() { return parseInt(localStorage.getItem(TITLE_KEY) || '0', 10) || 0; }
                let titleIdx = getStoredIdx();

                async function cycleTitleStep() {
                    try {
                        titleIdx = (titleIdx + 1) % variants.length;
                        localStorage.setItem(TITLE_KEY, String(titleIdx));
                        console.log('AUTO: cycling to', titleIdx, variants[titleIdx].id);
                        await animateTitleTo(variants[titleIdx].title);
                    } catch (e) { console.warn('AUTO: cycle failed', e); }
                }

                const AUTO_CYCLE_MS = 5200;
                let autoCycleRunning = false;

                // Self-scheduling auto-cycle to avoid overlaps and make timing predictable
                // Robust single-timer scheduler to avoid overlapping cycles
                let autoCycleTimer = null;
                function scheduleNextCycle() {
                    // guard: reduced motion / opt-out
                    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) { console.log('AUTO: reduced-motion detected — disabled'); return; }
                    if (localStorage.getItem('title_auto_cycle') === '0') { console.log('AUTO: user opt-out detected'); return; }

                    // clear any existing timer just in case
                    if (autoCycleTimer) {
                        clearTimeout(autoCycleTimer);
                        autoCycleTimer = null;
                    }

                    // schedule a single tick; after the animation completes we re-schedule
                    autoCycleTimer = setTimeout(async () => {
                        autoCycleTimer = null;
                        try {
                            await cycleTitleStep();
                        } catch (e) { console.warn('AUTO: cycle failed', e); }

                        // if still running, schedule the next one
                        if (autoCycleRunning) scheduleNextCycle();
                    }, AUTO_CYCLE_MS);
                    console.log('AUTO: scheduled next in', AUTO_CYCLE_MS, 'ms');
                }

                function startAutoCycle() {
                    if (autoCycleRunning) return;
                    autoCycleRunning = true;
                    console.log('AUTO: start');
                    scheduleNextCycle();
                }

                function stopAutoCycle() {
                    if (!autoCycleRunning && !autoCycleTimer) return;
                    console.log('AUTO: stop');
                    autoCycleRunning = false;
                    if (autoCycleTimer) { clearTimeout(autoCycleTimer); autoCycleTimer = null; }
                }

                // Pause while hovering hero
                const heroEl = document.getElementById('hero-copy');
                if (heroEl) { heroEl.addEventListener('mouseenter', stopAutoCycle); heroEl.addEventListener('mouseleave', startAutoCycle); }

                // Start
                startAutoCycle();
            })();
        })();
    </script>

    <!-- Custom cursor element and behavior -->
    <!-- Geometric Stealth HUD Cursor -->
    <div id="custom-cursor" aria-hidden="true">
        <svg class="cursor-svg" width="60" height="60" viewBox="0 0 60 60">
            <!-- Morphing paths - Clean, Symmetric Triangle -->
            <path class="cursor-outer" d="M30 15 L45 45 L15 45 Z" fill="none" stroke="currentColor" stroke-width="0.5" opacity="0.3" />
            <path class="cursor-inner" d="M30 22 L38 40 L22 40 Z" fill="none" stroke="currentColor" stroke-width="1.2" />
            
            <!-- Tech details (Hover: Dynamic Scanning elements) -->
            <g class="hover-details">
                <circle class="wave-1" cx="30" cy="30" r="14" fill="none" stroke="var(--accent)" stroke-width="1" opacity="0" />
                <circle class="wave-2" cx="30" cy="30" r="14" fill="none" stroke="var(--accent)" stroke-width="0.5" opacity="0" />
                <circle class="wave-3" cx="30" cy="30" r="14" fill="none" stroke="var(--accent)" stroke-width="0.5" opacity="0" />
            </g>

            <!-- Reticle lines -->
            <line class="reticle-v" x1="30" y1="20" x2="30" y2="40" stroke="currentColor" stroke-width="0.5" opacity="0.3" />
            <line class="reticle-h" x1="20" y1="30" x2="40" y2="30" stroke="currentColor" stroke-width="0" opacity="0" />
        </svg>
        <div class="cursor-status">
            <span class="status-mode">NAV-MODE</span>
            <span class="status-coords">000,000</span>
        </div>
    </div>
    <script>
    (function(){
        try {
            if ('ontouchstart' in window || (window.matchMedia && window.matchMedia('(pointer:coarse)').matches)) return;
            if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

            const cursor = document.getElementById('custom-cursor');
            const svg = cursor.querySelector('.cursor-svg');
            const inner = cursor.querySelector('.cursor-inner');
            const outer = cursor.querySelector('.cursor-outer');
            const status = cursor.querySelector('.cursor-status');
            const statusCoords = cursor.querySelector('.status-coords');
            const statusMode = cursor.querySelector('.status-mode');
            
            document.body.classList.add('has-custom-cursor');

            let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            let pos = { x: mouse.x, y: mouse.y };
            let visible = false;
            let rotation = 0;

            window.addEventListener('pointermove', (e) => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
                if (!visible) { cursor.style.opacity = '1'; visible = true; }
                scheduleHide();
            }, { passive: true });

            let hideTimer = null;
            function scheduleHide(){
                if (hideTimer) clearTimeout(hideTimer);
                hideTimer = setTimeout(() => { cursor.style.opacity = '0'; visible = false; }, 3000);
            }

            const hoverSelector = 'a, button, [role="button"], input, .cta-row a, .hud-link, .work-card, .site-logo';
            document.addEventListener('pointerover', (e) => {
                if (e.target.closest(hoverSelector)) {
                    document.body.classList.add('cursor-hovering');
                    if (statusMode) statusMode.textContent = 'TRGT-LOCK';
                }
            });
            document.addEventListener('pointerout', (e) => {
                const rt = e.relatedTarget;
                if (!rt || !rt.closest || !rt.closest(hoverSelector)) {
                    document.body.classList.remove('cursor-hovering');
                    if (statusMode) statusMode.textContent = 'NAV-MODE';
                }
            });

            function update() {
                const isHovering = document.body.classList.contains('cursor-hovering');
                // Smoothing for the lag effect
                const lerp = 0.12;
                pos.x += (mouse.x - pos.x) * lerp;
                pos.y += (mouse.y - pos.y) * lerp;

                const dx = mouse.x - pos.x;
                const dy = mouse.y - pos.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // Rotation logic: Point towards movement, or snap upright on hover
                if (isHovering) {
                    let diff = 0 - rotation;
                    while (diff < -180) diff += 360;
                    while (diff > 180) diff -= 360;
                    rotation += diff * 0.2;
                } else if (distance > 1) {
                    const targetRotation = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
                    let diff = targetRotation - rotation;
                    while (diff < -180) diff += 360;
                    while (diff > 180) diff -= 360;
                    rotation += diff * 0.15;
                }

                // Update SVG position - center it on mouse
                svg.style.transform = `translate(${mouse.x - 30}px, ${mouse.y - 30}px) rotate(${rotation}deg)`;
                
                // Warp outer frame based on movement (disabled on hover)
                if (!isHovering) {
                    const scaleY = 1 + (distance * 0.015);
                    const scaleX = 1 - (distance * 0.005);
                    outer.style.transform = `scale(${scaleX}, ${scaleY})`;
                } else {
                    outer.style.transform = `scale(1, 1)`;
                }
                outer.style.transformOrigin = '30px 30px';

                // Update STATUS HUD
                if (status) {
                    status.style.transform = `translate(${mouse.x + 25}px, ${mouse.y + 10}px)`;
                    if (statusCoords) statusCoords.textContent = `${Math.round(mouse.x)},${Math.round(mouse.y)}`;
                }

                requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        } catch (e) { console.warn('CURSOR: error', e); }
    })();
    </script>
    <script>
    (function(){
        // Stack persistence and process step interaction
        const layers = document.querySelectorAll('.stack-layer');
        const processSteps = document.querySelectorAll('.process-step[data-step]');
        
        if (layers.length) {
            // Map process steps to layer groups
            // Step 1 (Strategic Foundation) -> Layers 7, 6, 5 (top 3)
            // Step 2 (Technical Execution) -> Layers 4, 3 (middle 2)
            // Step 3 (Measurable Impact) -> Layers 2, 1 (bottom 2)
            const stepToLayers = {
                '1': ['layer-7', 'layer-6', 'layer-5'],
                '2': ['layer-4', 'layer-3'],
                '3': ['layer-2', 'layer-1']
            };

            // Layer hover logic
            layers.forEach(layer => {
                layer.addEventListener('mouseenter', () => {
                    layers.forEach(l => l.classList.remove('is-active'));
                    layer.classList.add('is-active');
                });
            });

            // Process step hover logic
            processSteps.forEach(step => {
                step.addEventListener('mouseenter', () => {
                    const stepNum = step.getAttribute('data-step');
                    const targetLayers = stepToLayers[stepNum] || [];
                    
                    // Clear all
                    layers.forEach(l => l.classList.remove('is-active'));
                    
                    // Activate corresponding layers
                    targetLayers.forEach(layerClass => {
                        const layer = document.querySelector('.' + layerClass);
                        if (layer) layer.classList.add('is-active');
                    });
                });

                step.addEventListener('mouseleave', () => {
                    // Keep the active state; don't clear on leave
                });
            });

            // Clear on general container leave
            const processContainer = document.querySelector('.process-list');
            if (processContainer) {
                processContainer.addEventListener('mouseleave', () => {
                    layers.forEach(l => l.classList.remove('is-active'));
                });
            }
        }
    })();
    </script>
</body>
</html>
